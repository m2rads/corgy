<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>AR AI Dog</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        #ui {
            position: absolute;
            bottom: 20px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: center;
            pointer-events: none;
        }
        .button {
            background: rgba(255, 255, 255, 0.7);
            border: none;
            border-radius: 30px;
            padding: 12px 20px;
            margin: 0 10px;
            font-weight: bold;
            pointer-events: auto;
        }
        /* New styles for fallback mode */
        #fallback-mode {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            display: none;
        }
        #fallback-button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            margin-top: 15px;
            cursor: pointer;
            font-weight: bold;
        }
        /* End new styles */
        #status {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 10px;
            border-radius: 5px;
            max-width: 80%;
        }
        #speech-input {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            padding: 12px;
            border-radius: 30px;
            border: none;
            background: rgba(255, 255, 255, 0.9);
            display: none;
            pointer-events: auto;
        }
        .thinking {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px 20px;
            border-radius: 10px;
            display: none;
        }
        /* Debug panel styles */
        #debug-panel {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.8);
            color: lime;
            font-family: monospace;
            font-size: 10px;
            max-height: 30%;
            overflow-y: auto;
            padding: 10px;
            display: none;
        }
        #debug-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="status">Looking for surface...</div>
    <div id="thinking" class="thinking">Dog is thinking...</div>
    <input type="text" id="speech-input" placeholder="Say something to the dog...">
    <div id="ui">
        <button id="start-ar" class="button">Start AR</button>
        <button id="place-dog" class="button" style="display: none;">Place Dog</button>
        <button id="talk" class="button" style="display: none;">Talk</button>
        <button id="pet" class="button" style="display: none;">Pet</button>
        <button id="throw-ball" class="button" style="display: none;">Throw Ball</button>
    </div>
    
    <!-- Debug Tools -->
    <button id="debug-toggle">Show Debug</button>
    <div id="debug-panel"></div>

    <!-- Fallback Mode UI -->
    <div id="fallback-mode">
        <h3>AR Not Supported</h3>
        <p>Your device or browser doesn't support WebXR for AR.</p>
        <p>You can still view the dog in 3D mode instead.</p>
        <button id="fallback-button">View in 3D Mode</button>
    </div>

    <!-- Import libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r132/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/DRACOLoader.js"></script>
    <!-- Add WebXR polyfills for better iOS support -->
    <script src="https://unpkg.com/webxr-polyfill@latest/build/webxr-polyfill.js"></script>

    <script>
    // Initialize WebXR polyfill first
    const polyfill = new WebXRPolyfill({
        // Specific options for iOS
        allowCardboardOnDesktop: true,
        enableLegacyWebVR: true
    });
    
    // Debug logger
    const logger = {
        logs: [],
        maxLogs: 100,
        
        log: function(message, type = 'info') {
            const timestamp = new Date().toISOString().substring(11, 23);
            const entry = `${timestamp} [${type.toUpperCase()}] ${message}`;
            this.logs.unshift(entry);
            
            // Trim log if needed
            if (this.logs.length > this.maxLogs) {
                this.logs.pop();
            }
            
            // Update debug panel if visible
            this.updatePanel();
            
            // Also log to console
            console.log(entry);
            
            // Send to server for logging important events
            if (type === 'error' || type === 'warn') {
                this.sendToServer(entry, type);
            }
        },
        
        info: function(message) {
            this.log(message, 'info');
        },
        
        warn: function(message) {
            this.log(message, 'warn');
        },
        
        error: function(message, error) {
            let errorDetails = message;
            if (error) {
                errorDetails += `: ${error.message || error}`;
                console.error(error);
            }
            this.log(errorDetails, 'error');
        },
        
        updatePanel: function() {
            const panel = document.getElementById('debug-panel');
            if (panel) {
                panel.innerHTML = this.logs.join('<br>');
            }
        },
        
        sendToServer: function(message, type) {
            try {
                fetch('/api/log', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        message,
                        type,
                        userAgent: navigator.userAgent,
                        timestamp: new Date().toISOString()
                    })
                }).catch(e => {
                    console.error('Failed to send log to server', e);
                    // Don't worry about server logging failing
                });
            } catch (e) {
                console.error('Error sending log to server', e);
                // Continue even if server logging fails
            }
        },
        
        checkXRCapabilities: function() {
            this.info('Checking XR capabilities...');
            
            // Try to check AR capabilities on server but don't rely on response
            fetch('/api/check-ar')
                .then(res => res.json())
                .then(data => {
                    this.info(`AR check endpoint response: ${JSON.stringify(data.message)}`);
                })
                .catch(err => {
                    this.info('AR check endpoint failed - continuing in offline mode');
                });
                
            // Check navigator.xr
            if (!navigator.xr) {
                this.error('WebXR API not available on this browser');
                return false;
            } else {
                this.info('WebXR API is available');
            }
            
            // Return results of basic check
            return !!navigator.xr;
        }
    };
    
    // Initialize debug panel
    document.getElementById('debug-toggle').addEventListener('click', function() {
        const panel = document.getElementById('debug-panel');
        if (panel.style.display === 'none' || !panel.style.display) {
            panel.style.display = 'block';
            this.textContent = 'Hide Debug';
        } else {
            panel.style.display = 'none';
            this.textContent = 'Show Debug';
        }
    });

    // Add fallback mode functionality
    document.getElementById('fallback-button').addEventListener('click', function() {
        document.getElementById('fallback-mode').style.display = 'none';
        startFallback3DMode();
    });

    // Main Application
    class ARDogApp {
        constructor() {
            // Scene setup
            this.canvas = document.getElementById('canvas');
            this.scene = new THREE.Scene();
            this.camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);
            
            // Renderer with iOS-friendly settings
            this.renderer = new THREE.WebGLRenderer({ 
                canvas: this.canvas, 
                antialias: true, 
                alpha: true,
                powerPreference: "high-performance",
                precision: "highp"
            });
            this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limit pixel ratio for performance
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.renderer.xr.enabled = true;
            
            // Extra debugging for iOS
            logger.info(`Using WebGL Renderer: ${this.renderer.getContext().getParameter(this.renderer.getContext().VERSION)}`);
            logger.info(`Renderer pixel ratio: ${this.renderer.getPixelRatio()}`);
            
            // AR elements
            this.hitTestSource = null;
            this.hitTestSourceRequested = false;
            this.reticle = new THREE.Mesh(
                new THREE.RingGeometry(0.15, 0.2, 32).rotateX(-Math.PI / 2),
                new THREE.MeshBasicMaterial()
            );
            this.reticle.matrixAutoUpdate = false;
            this.reticle.visible = false;
            this.scene.add(this.reticle);
            
            // Dog model and variables
            this.dog = null;
            this.dogPlaced = false;
            this.dogAnimations = {};
            this.currentAnimation = null;
            this.mixer = null;
            this.clock = new THREE.Clock();
            this.dogState = {
                mood: "neutral", // neutral, happy, sad, excited, tired
                lastInteractions: [],
                energy: 100,
                memory: {}
            };
            
            // LLM context
            this.llmContext = {
                currentPrompt: "",
                systemPrompt: `You are an AI dog in an augmented reality experience. You behave just like a real friendly dog would. 
                Your responses should be short actions the dog would take, using only a few words.
                Never speak in full sentences, just give the dog's actions and maybe a sound (like "woof!" or "whines").
                For example: "wags tail excitedly", "tilts head curiously", "jumps up and down, barking", "lies down and looks sad".
                You should never talk like a human - remember you are a dog!`,
                memory: []
            };
            
            // Physics objects
            this.ball = null;
            
            // UI elements
            this.statusEl = document.getElementById('status');
            this.startARButton = document.getElementById('start-ar');
            this.placeDogButton = document.getElementById('place-dog');
            this.talkButton = document.getElementById('talk');
            this.petButton = document.getElementById('pet');
            this.throwBallButton = document.getElementById('throw-ball');
            this.speechInput = document.getElementById('speech-input');
            this.thinkingEl = document.getElementById('thinking');
            
            // Initialize
            this.setupLighting();
            this.setupEventListeners();
            this.initARButton();
        }
        
        setupLighting() {
            const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
            light.position.set(0.5, 1, 0.25);
            this.scene.add(light);
        }
        
        initARButton() {
            this.startARButton.addEventListener('click', () => {
                logger.info('Start AR button clicked');
                // Add a user gesture handler for iOS - Safari requires user gesture
                this.startARSession();
            });
        }
        
        startARSession() {
            logger.info('Starting AR session with WebXR version: ' + (navigator.xr ? 'Available' : 'Not available'));
            
            // Make sure this is being called from a user gesture for iOS Safari
            if (!navigator.xr) {
                logger.error('WebXR API not available in this browser');
                
                const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
                if (isIOS) {
                    logger.info('iOS device detected, attempting WebXR polyfill');
                    // Force showing the AR button on iOS even if navigator.xr is not detected
                    // The WebXR polyfill might make it work
                    this.statusEl.innerHTML = 'Using WebXR polyfill. If this does not work, your device may not support AR.';
                    
                    // Try to initialize AR anyway - the polyfill might handle it
                    this.tryInitializeAR();
                } else {
                    this.statusEl.innerHTML = 'AR not supported on this device/browser.';
                    // Show fallback mode
                    document.getElementById('fallback-mode').style.display = 'block';
                }
                return;
            }
            
            this.tryInitializeAR();
        }
        
        tryInitializeAR() {
            logger.info('Trying to initialize AR');
            
            if (typeof navigator.xr.isSessionSupported !== 'function') {
                logger.error('isSessionSupported is not a function - polyfill may not be working correctly');
                this.statusEl.innerHTML = 'WebXR API not fully supported on this browser.';
                // Show fallback mode
                document.getElementById('fallback-mode').style.display = 'block';
                return;
            }
            
            navigator.xr.isSessionSupported('immersive-ar')
                .then((supported) => {
                    if (supported) {
                        logger.info('immersive-ar is supported, requesting session');
                        
                        // Use minimal required features for iOS compatibility
                        const sessionInit = { 
                            requiredFeatures: ['hit-test'],
                            optionalFeatures: ['dom-overlay'],
                        };
                        
                        // Add dom-overlay only if supported
                        if (sessionInit.optionalFeatures.includes('dom-overlay')) {
                            sessionInit.domOverlay = { root: document.body };
                        }
                        
                        navigator.xr.requestSession('immersive-ar', sessionInit)
                            .then(session => {
                                logger.info('AR session created successfully');
                                this.onSessionStarted(session);
                            })
                            .catch(error => {
                                logger.error('Failed to start AR session', error);
                                
                                if (error.message.includes('permission')) {
                                    this.statusEl.textContent = 'Camera permission denied. Please allow camera access.';
                                } else {
                                    this.statusEl.textContent = `AR session failed: ${error.message || error}`;
                                }
                                // Show fallback mode
                                document.getElementById('fallback-mode').style.display = 'block';
                            });
                    } else {
                        logger.error('immersive-ar not supported on this device');
                        this.statusEl.innerHTML = 'AR not supported on this device. Your device might not have AR capabilities.';
                        // Show fallback mode
                        document.getElementById('fallback-mode').style.display = 'block';
                    }
                })
                .catch(error => {
                    logger.error('Error checking AR support', error);
                    this.statusEl.textContent = `Error checking AR support: ${error.message || error}`;
                    // Show fallback mode
                    document.getElementById('fallback-mode').style.display = 'block';
                });
        }
        
        onSessionStarted(session) {
            logger.info('AR session started, configuring');
            this.startARButton.style.display = 'none';
            this.placeDogButton.style.display = 'block';
            
            this.renderer.xr.setReferenceSpaceType('local');
            this.renderer.xr.setSession(session);
            
            session.addEventListener('end', this.onSessionEnded.bind(this));
            
            this.placeDogButton.addEventListener('click', this.placeDog.bind(this));
            this.talkButton.addEventListener('click', this.activateSpeechInput.bind(this));
            this.petButton.addEventListener('click', () => this.interactWithDog('pet'));
            this.throwBallButton.addEventListener('click', () => this.throwBall());
            
            this.speechInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    const text = this.speechInput.value.trim();
                    if (text) {
                        this.talkToDog(text);
                        this.speechInput.value = '';
                        this.speechInput.style.display = 'none';
                    }
                }
            });
            
            this.loadDogModel();
            
            this.renderer.setAnimationLoop(this.render.bind(this));
        }
        
        onSessionEnded() {
            this.startARButton.style.display = 'block';
            this.placeDogButton.style.display = 'none';
            this.talkButton.style.display = 'none';
            this.petButton.style.display = 'none';
            this.throwBallButton.style.display = 'none';
            this.renderer.setAnimationLoop(null);
        }
        
        async loadDogModel() {
            this.statusEl.textContent = 'Loading dog model...';
            
            // Load the corgy.glb model using GLTFLoader
            const loader = new THREE.GLTFLoader();
            
            try {
                const gltf = await new Promise((resolve, reject) => {
                    loader.load(
                        '/assets/corgy.glb',  // Path to the model
                        resolve,
                        (xhr) => {
                            console.log((xhr.loaded / xhr.total * 100) + '% loaded');
                        },
                        reject
                    );
                });
                
                this.dog = gltf.scene;
                
                // Scale if needed (adjust based on your model size)
                this.dog.scale.set(0.15, 0.15, 0.15);
                
                // Center the model if needed
                const box = new THREE.Box3().setFromObject(this.dog);
                const center = box.getCenter(new THREE.Vector3());
                this.dog.position.x += (this.dog.position.x - center.x);
                this.dog.position.y += (this.dog.position.y - center.y) + 0.3;
                this.dog.position.z += (this.dog.position.z - center.z);
                
                // Setup animations if your model has them
                if (gltf.animations && gltf.animations.length) {
                    this.mixer = new THREE.AnimationMixer(this.dog);
                    
                    // Store animations
                    gltf.animations.forEach(clip => {
                        const action = this.mixer.clipAction(clip);
                        this.dogAnimations[clip.name] = action;
                    });
                    
                    // Define animation mappings
                    if (!this.dogAnimations['idle'] && gltf.animations.length > 0) {
                        // If no specific 'idle' animation, use the first one as default
                        this.dogAnimations['idle'] = this.mixer.clipAction(gltf.animations[0]);
                    }
                    
                    // Check for other common animations and create mappings
                    const animationNames = gltf.animations.map(a => a.name.toLowerCase());
                    
                    if (!this.dogAnimations['walking']) {
                        // Try to find walking animation
                        const walkIndex = animationNames.findIndex(n => 
                            n.includes('walk') || n.includes('run') || n.includes('trot'));
                        if (walkIndex >= 0) {
                            this.dogAnimations['walking'] = this.mixer.clipAction(gltf.animations[walkIndex]);
                        } else {
                            // Fallback to idle
                            this.dogAnimations['walking'] = this.dogAnimations['idle'];
                        }
                    }
                    
                    if (!this.dogAnimations['excited']) {
                        // Try to find excited animation
                        const excitedIndex = animationNames.findIndex(n => 
                            n.includes('jump') || n.includes('bark') || n.includes('excited'));
                        if (excitedIndex >= 0) {
                            this.dogAnimations['excited'] = this.mixer.clipAction(gltf.animations[excitedIndex]);
                        } else {
                            // Fallback to idle
                            this.dogAnimations['excited'] = this.dogAnimations['idle'];
                        }
                    }
                    
                    // Play default animation
                    this.playDogAnimation('idle');
                }
                
                this.dog.visible = false;  // Hide until placed
                this.scene.add(this.dog);
                
                this.statusEl.textContent = 'Dog model loaded! Find a surface to place it.';
                
            } catch (error) {
                console.error('Error loading dog model:', error);
                this.statusEl.textContent = 'Error loading dog model. Using fallback.';
                
                // Fallback to primitive dog if model loading fails
                this.createPrimitiveDog();
            }
        }
        
        createPrimitiveDog() {
            // Create a simple dog placeholder using primitives
            const dogGroup = new THREE.Group();
            
            // Body
            const body = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.06, 0.12, 4, 8),
                new THREE.MeshStandardMaterial({ color: 0xA0522D })
            );
            body.rotation.z = Math.PI / 2;
            body.position.y = 0.12;
            dogGroup.add(body);
            
            // Head
            const head = new THREE.Mesh(
                new THREE.SphereGeometry(0.045, 16, 16),
                new THREE.MeshStandardMaterial({ color: 0x8B4513 })
            );
            head.position.set(0.09, 0.16, 0);
            dogGroup.add(head);
            
            // Eyes
            const eyeGeometry = new THREE.SphereGeometry(0.01, 8, 8);
            const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(0.12, 0.18, 0.025);
            dogGroup.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.12, 0.18, -0.025);
            dogGroup.add(rightEye);
            
            // Nose
            const nose = new THREE.Mesh(
                new THREE.SphereGeometry(0.012, 8, 8),
                new THREE.MeshBasicMaterial({ color: 0x000000 })
            );
            nose.position.set(0.14, 0.15, 0);
            dogGroup.add(nose);
            
            // Legs
            const legGeometry = new THREE.CylinderGeometry(0.012, 0.012, 0.06, 8);
            const legMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            
            const legs = [];
            const legPositions = [
                [-0.04, 0.1, 0.04],
                [-0.04, 0.1, -0.04],
                [0.04, 0.1, 0.04],
                [0.04, 0.1, -0.04]
            ];
            
            legPositions.forEach(pos => {
                const leg = new THREE.Mesh(legGeometry, legMaterial);
                leg.position.set(...pos);
                dogGroup.add(leg);
                legs.push(leg);
            });
            
            // Tail
            const tail = new THREE.Mesh(
                new THREE.CylinderGeometry(0.01, 0.003, 0.06, 8),
                new THREE.MeshStandardMaterial({ color: 0x8B4513 })
            );
            tail.position.set(-0.1, 0.12, 0);
            tail.rotation.z = Math.PI / 4;
            dogGroup.add(tail);
            
            // Add to scene
            this.dog = dogGroup;
            this.scene.add(this.dog);
            
            // Define primitive animations with more variety
            this.dogAnimations = {
                idle: { duration: 2000, onUpdate: (t) => {
                    const y = 0.05 * Math.sin(t * Math.PI);
                    body.position.y = 0.12 + y * 0.02;
                    head.position.y = 0.16 + y * 0.02;
                }},
                walking: { duration: 1000, onUpdate: (t) => {
                    const cycle = t * Math.PI * 2;
                    legs.forEach((leg, i) => {
                        leg.position.y = 0.06 + Math.abs(Math.sin(cycle + i * Math.PI/2)) * 0.005;
                    });
                    body.position.y = 0.12 + Math.sin(cycle * 2) * 0.002;
                    // Add slight head bob while walking
                    head.position.y = 0.16 + Math.sin(cycle * 2) * 0.005;
                }},
                excited: { duration: 800, onUpdate: (t) => {
                    const cycle = t * Math.PI * 4;
                    body.position.y = 0.12 + Math.abs(Math.sin(cycle)) * 0.01;
                    head.position.y = 0.16 + Math.abs(Math.sin(cycle)) * 0.01;
                    tail.rotation.z = Math.PI / 4 + Math.sin(cycle * 2) * 0.05;
                    // Add slight body rotation for more excitement
                    body.rotation.x = Math.sin(cycle) * 0.05;
                }},
                sleeping: { duration: 3000, onUpdate: (t) => {
                    const breathing = Math.sin(t * Math.PI) * 0.002;
                    body.scale.y = 1 + breathing;
                    // Lower head position for sleeping pose
                    head.position.y = 0.14 + breathing * 0.5;
                }},
                // New animations
                run: { duration: 600, onUpdate: (t) => {
                    const cycle = t * Math.PI * 3; // Faster cycle for running
                    legs.forEach((leg, i) => {
                        leg.position.y = 0.06 + Math.abs(Math.sin(cycle + i * Math.PI/2)) * 0.01;
                    });
                    body.position.y = 0.12 + Math.sin(cycle * 2) * 0.005;
                    head.position.y = 0.16 + Math.sin(cycle * 2) * 0.008;
                    tail.rotation.z = Math.PI / 4 + Math.sin(cycle) * 0.1;
                }},
                fetch: { duration: 1500, onUpdate: (t) => {
                    if (t < 0.5) {
                        // Running to fetch
                        const cycle = t * Math.PI * 6;
                        legs.forEach((leg, i) => {
                            leg.position.y = 0.06 + Math.abs(Math.sin(cycle + i * Math.PI/2)) * 0.01;
                        });
                        body.position.y = 0.12 + Math.sin(cycle * 2) * 0.005;
                    } else {
                        // Coming back
                        const cycle = (t - 0.5) * Math.PI * 4;
                        body.position.y = 0.12 + Math.abs(Math.sin(cycle)) * 0.01;
                        head.position.y = 0.16 + Math.abs(Math.sin(cycle)) * 0.01;
                        tail.rotation.z = Math.PI / 4 + Math.sin(cycle * 2) * 0.1;
                    }
                }}
            };
            
            // Override the updateDogAnimation method for primitive animations
            this.updateDogAnimationOriginal = this.updateDogAnimation;
            this.updateDogAnimation = () => {
                if (!this.currentAnimation || !this.dog) return;
                
                const elapsed = Date.now() - this.currentAnimation.startTime;
                const t = (elapsed % this.currentAnimation.duration) / this.currentAnimation.duration;
                
                this.currentAnimation.onUpdate(t);
            };
            
            // Override the playDogAnimation method for primitive animations
            this.playDogAnimationOriginal = this.playDogAnimation;
            this.playDogAnimation = (name) => {
                this.currentAnimation = {
                    name,
                    startTime: Date.now(),
                    ...this.dogAnimations[name]
                };
            };
            
            this.playDogAnimation('idle');
            this.dog.visible = false; // Hide until placed
            this.statusEl.textContent = 'Using fallback dog model. Find a surface to place it.';
        }
        
        updateDogAnimation() {
            // Update animation mixer if it exists
            if (this.mixer) {
                const delta = this.clock.getDelta();
                this.mixer.update(delta);
            }
        }
        
        playDogAnimation(name) {
            if (!this.dogAnimations || Object.keys(this.dogAnimations).length === 0) {
                return; // No animations available
            }
            
            // Stop any current animation
            if (this.currentAnimation) {
                this.currentAnimation.fadeOut(0.5);
            }
            
            // Get animation by name (case insensitive)
            let animation = this.dogAnimations[name];
            if (!animation) {
                // Try lowercase
                animation = this.dogAnimations[name.toLowerCase()];
            }
            
            // If still not found, use idle as fallback
            if (!animation && this.dogAnimations['idle']) {
                animation = this.dogAnimations['idle'];
            } else if (!animation && Object.values(this.dogAnimations).length > 0) {
                // Last resort: just use the first available animation
                animation = Object.values(this.dogAnimations)[0];
            }
            
            if (animation) {
                animation.reset().fadeIn(0.5).play();
                this.currentAnimation = animation;
            }
        }
        
        placeDog() {
            if (!this.reticle.visible) {
                this.statusEl.textContent = 'Can\'t place dog yet - find a surface';
                return;
            }
            
            if (!this.dogPlaced) {
                this.dog.position.setFromMatrixPosition(this.reticle.matrix);
                this.dog.visible = true;
                this.dogPlaced = true;
                
                this.placeDogButton.style.display = 'none';
                this.talkButton.style.display = 'block';
                this.petButton.style.display = 'block';
                this.throwBallButton.style.display = 'block';
                
                this.statusEl.textContent = 'Your dog is ready! Interact with it.';
                
                // Initial greeting from the dog
                setTimeout(() => {
                    this.simulateLLMResponse('A user has just placed you in their room. How do you react?');
                }, 1000);
            }
        }
        
        activateSpeechInput() {
            this.speechInput.style.display = 'block';
            this.speechInput.focus();
        }
        
        async talkToDog(text) {
            this.statusEl.textContent = `You: ${text}`;
            this.playDogAnimation('excited');
            
            await this.simulateLLMResponse(`The user says to you: "${text}". How do you respond as a dog?`);
        }
        
        async interactWithDog(action) {
            if (action === 'pet') {
                this.statusEl.textContent = 'You pet the dog';
                await this.simulateLLMResponse('The user is petting you. How do you react?');
            }
        }
        
        throwBall() {
            if (!this.ball) {
                // Create a ball
                this.ball = new THREE.Mesh(
                    new THREE.SphereGeometry(0.05, 16, 16),
                    new THREE.MeshStandardMaterial({ color: 0xff0000 })
                );
                this.scene.add(this.ball);
            }
            
            // Position the ball near the dog
            this.ball.position.copy(this.dog.position);
            this.ball.position.y += 0.5;
            this.ball.position.z += 0.5;
            this.ball.visible = true;
            
            // Simulate throwing animation
            const startPos = this.ball.position.clone();
            const endPos = this.dog.position.clone();
            endPos.x += (Math.random() - 0.5) * 2;
            endPos.z += (Math.random() - 0.5) * 2;
            
            const animateBall = () => {
                const progress = (Date.now() - throwStart) / 1000; // 1 second animation
                
                if (progress < 1) {
                    // Parabolic arc
                    const t = progress;
                    this.ball.position.x = startPos.x + (endPos.x - startPos.x) * t;
                    this.ball.position.z = startPos.z + (endPos.z - startPos.z) * t;
                    this.ball.position.y = startPos.y + 1 * Math.sin(Math.PI * t); // Arc height
                    
                    requestAnimationFrame(animateBall);
                } else {
                    this.ball.position.copy(endPos);
                    this.ball.position.y = 0.05; // On the ground
                    
                    // Make the dog react to the ball
                    this.simulateLLMResponse('The user threw a ball near you. How do you react?');
                }
            };
            
            const throwStart = Date.now();
            animateBall();
            
            this.statusEl.textContent = 'You threw a ball';
        }
        
        async simulateLLMResponse(prompt) {
            // Show thinking indicator
            this.thinkingEl.style.display = 'block';
            
            // Add to context
            this.llmContext.currentPrompt = prompt;
            this.llmContext.memory.push({ role: "user", content: prompt });
            
            let response = "";
            
            try {
                // Try to use the real API first
                response = await this.callLLMAPI(prompt);
            } catch (error) {
                console.error('Error using LLM API, falling back to simulation:', error);
                
                // Simulate API delay
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                // Simulate responses based on prompt keywords (fallback)
                if (prompt.includes("placed you in")) {
                    response = "wags tail excitedly, looks around curiously, then sits and tilts head";
                    // Animation handled by behavior interpreter now
                } else if (prompt.includes("petting you")) {
                    response = "closes eyes happily, leans into the pets, tail thumps against floor";
                    // Animation handled by behavior interpreter now
                } else if (prompt.includes("threw a ball")) {
                    response = "barks excitedly, runs to ball, picks it up and brings it back, tail wagging";
                    // Animation handled by behavior interpreter now
                } else if (prompt.includes("says to you")) {
                    // Pick a random response for speech
                    const responses = [
                        "tilts head curiously, ears perked up",
                        "wags tail and makes excited whining sound",
                        "barks once and jumps up slightly",
                        "sits attentively, looking at you with head tilted"
                    ];
                    response = responses[Math.floor(Math.random() * responses.length)];
                    // Animation handled by behavior interpreter now
                } else {
                    response = "looks at you with head tilted";
                }
            }
            
            // Add to memory
            this.llmContext.memory.push({ role: "assistant", content: response });
            
            // Limit memory to last 10 interactions
            if (this.llmContext.memory.length > 10) {
                this.llmContext.memory = this.llmContext.memory.slice(-10);
            }
            
            this.statusEl.textContent = `Dog: ${response}`;
            this.thinkingEl.style.display = 'none';
            
            // Process dog behavior based on AI response
            this.interpretAndExecuteBehavior(response);
            
            return response;
        }
        
        // New behavior interpreter system
        interpretAndExecuteBehavior(aiResponse) {
            logger.info(`Interpreting behavior: "${aiResponse}"`);
            
            // Parse the AI response for behavior cues
            const behaviors = this.parseBehaviors(aiResponse);
            
            // Execute the behaviors in sequence
            this.executeBehaviorSequence(behaviors);
        }
        
        parseBehaviors(response) {
            // Common dog behavior keywords to look for
            const behaviorMap = {
                // Body animations
                'wag': { type: 'animation', action: 'excited', duration: 3000 },
                'tail': { type: 'animation', action: 'excited', duration: 2500 },
                'jump': { type: 'animation', action: 'excited', duration: 1500 },
                'excited': { type: 'animation', action: 'excited', duration: 3000 },
                'bark': { type: 'animation', action: 'excited', duration: 1000, sound: 'bark' },
                'play': { type: 'animation', action: 'excited', duration: 3000 },
                'run': { type: 'movement', action: 'run', distance: 1, duration: 2000 },
                'sit': { type: 'animation', action: 'idle', duration: 2000 },
                'lies down': { type: 'animation', action: 'sleeping', duration: 3000 },
                'lying': { type: 'animation', action: 'sleeping', duration: 3000 },
                'sleep': { type: 'animation', action: 'sleeping', duration: 4000 },
                'tilt': { type: 'animation', action: 'idle', duration: 2000 },
                'sniff': { type: 'animation', action: 'walking', duration: 1500 },
                'walk': { type: 'movement', action: 'walk', distance: 0.5, duration: 2000 },
                'pant': { type: 'animation', action: 'idle', duration: 2000 },
                'lick': { type: 'animation', action: 'excited', duration: 1000 },
                'whine': { type: 'animation', action: 'idle', duration: 1500, sound: 'whine' },
                
                // Emotional states
                'happy': { type: 'emotion', value: 'happy' },
                'sad': { type: 'emotion', value: 'sad' },
                'curious': { type: 'emotion', value: 'curious' },
                'scared': { type: 'emotion', value: 'scared' },
                'confused': { type: 'emotion', value: 'confused' },
                'attentive': { type: 'emotion', value: 'attentive' },
                
                // Movements
                'brings it back': { type: 'movement', action: 'fetch', target: 'ball', duration: 3000 },
                'picks it up': { type: 'movement', action: 'pickup', target: 'ball', duration: 1500 },
                'rolls over': { type: 'animation', action: 'excited', duration: 2000 },
                'spins': { type: 'movement', action: 'spin', duration: 1500 },
                'circles': { type: 'movement', action: 'circle', duration: 2000 },
                'comes': { type: 'movement', action: 'approach', target: 'user', duration: 2000 },
                'follows': { type: 'movement', action: 'follow', target: 'user', duration: 3000 },
                'chases': { type: 'movement', action: 'chase', target: 'ball', duration: 2500 },
            };
            
            // Find matching behaviors in the response
            const behaviors = [];
            const responseLower = response.toLowerCase();
            
            // Check for comma or and separated actions
            const segments = responseLower.split(/,|\band\b/);
            
            segments.forEach(segment => {
                // Find all behavior matches in this segment
                const matches = Object.keys(behaviorMap).filter(key => segment.includes(key));
                
                if (matches.length > 0) {
                    // Use the longest matching behavior if multiple match
                    const bestMatch = matches.sort((a, b) => b.length - a.length)[0];
                    behaviors.push({...behaviorMap[bestMatch]});
                } else if (segment.trim().length > 0) {
                    // If no specific match, default to an emotion based on segment content
                    // This is a simple sentiment analysis
                    if (segment.match(/happy|excited|playful|joy|wag/i)) {
                        behaviors.push({ type: 'emotion', value: 'happy' });
                    } else if (segment.match(/sad|upset|unhappy|down/i)) {
                        behaviors.push({ type: 'emotion', value: 'sad' });
                    } else if (segment.match(/curious|interest|wonder/i)) {
                        behaviors.push({ type: 'emotion', value: 'curious' });
                    } else if (segment.match(/scared|afraid|fear|nervous/i)) {
                        behaviors.push({ type: 'emotion', value: 'scared' });
                    } else if (segment.match(/confused|puzzled|unsure/i)) {
                        behaviors.push({ type: 'emotion', value: 'confused' });
                    } else {
                        // Default animation if we can't categorize the segment
                        behaviors.push({ type: 'animation', action: 'idle', duration: 2000 });
                    }
                }
            });
            
            // If no behaviors found, default to idle
            if (behaviors.length === 0) {
                behaviors.push({ type: 'animation', action: 'idle', duration: 2000 });
            }
            
            logger.info(`Parsed behaviors: ${JSON.stringify(behaviors)}`);
            return behaviors;
        }
        
        async executeBehaviorSequence(behaviors) {
            // Execute each behavior in sequence
            for (const behavior of behaviors) {
                await this.executeBehavior(behavior);
            }
            
            // Return to idle state after all behaviors
            this.playDogAnimation('idle');
        }
        
        async executeBehavior(behavior) {
            logger.info(`Executing behavior: ${JSON.stringify(behavior)}`);
            
            switch (behavior.type) {
                case 'animation':
                    // Play the animation and wait for completion
                    this.playDogAnimation(behavior.action);
                    if (behavior.sound) {
                        this.playDogSound(behavior.sound);
                    }
                    await new Promise(resolve => setTimeout(resolve, behavior.duration));
                    break;
                    
                case 'emotion':
                    // Update the dog's emotional state
                    this.dogState.mood = behavior.value;
                    // Emotions affect animations
                    switch (behavior.value) {
                        case 'happy':
                            this.playDogAnimation('excited');
                            break;
                        case 'sad':
                            this.playDogAnimation('idle'); // We could add a sad animation later
                            break;
                        case 'curious':
                        case 'confused':
                            this.playDogAnimation('idle'); // For head tilting
                            break;
                        case 'scared':
                            this.playDogAnimation('idle'); // Could add scared animation
                            break;
                        default:
                            this.playDogAnimation('idle');
                    }
                    await new Promise(resolve => setTimeout(resolve, 1500));
                    break;
                    
                case 'movement':
                    // Handle movement behaviors
                    await this.executeDogMovement(behavior);
                    break;
                    
                default:
                    this.playDogAnimation('idle');
                    await new Promise(resolve => setTimeout(resolve, 1000));
            }
        }
        
        async executeDogMovement(movementBehavior) {
            const { action, target, distance, duration } = movementBehavior;
            
            // Play appropriate animation
            this.playDogAnimation(action === 'run' ? 'excited' : 'walking');
            
            switch (action) {
                case 'walk':
                case 'run':
                    // Simple movement animation
                    // In real implementation, we would animate position change
                    // For now, we'll just delay to simulate movement
                    await new Promise(resolve => setTimeout(resolve, duration));
                    break;
                    
                case 'fetch':
                case 'chase':
                    if (this.ball && this.ball.visible) {
                        // Animate the dog moving to the ball position
                        // In a more complex implementation, we'd move the dog model
                        this.playDogAnimation('walking');
                        await new Promise(resolve => setTimeout(resolve, duration * 0.6));
                        
                        // Then animate returning with the ball
                        this.playDogAnimation('excited');
                        // Hide the ball as if the dog picked it up
                        this.ball.visible = false;
                        await new Promise(resolve => setTimeout(resolve, duration * 0.4));
                    } else {
                        // Just play an excited animation if no ball
                        this.playDogAnimation('excited');
                        await new Promise(resolve => setTimeout(resolve, duration));
                    }
                    break;
                    
                case 'pickup':
                    if (this.ball && this.ball.visible) {
                        // Animate picking up the ball
                        this.playDogAnimation('idle');
                        await new Promise(resolve => setTimeout(resolve, duration * 0.5));
                        
                        // Hide the ball as if the dog picked it up
                        this.ball.visible = false;
                        await new Promise(resolve => setTimeout(resolve, duration * 0.5));
                    } else {
                        await new Promise(resolve => setTimeout(resolve, duration));
                    }
                    break;
                    
                case 'approach':
                case 'follow':
                    // Simulate approaching the user
                    this.playDogAnimation('walking');
                    await new Promise(resolve => setTimeout(resolve, duration));
                    break;
                    
                case 'spin':
                case 'circle':
                    // For primitive dog, we can rotate the whole model
                    const startTime = Date.now();
                    const animate = () => {
                        const elapsed = Date.now() - startTime;
                        if (elapsed < duration) {
                            // Rotate the dog model
                            if (this.dog) {
                                this.dog.rotation.y += 0.05;
                            }
                            requestAnimationFrame(animate);
                        }
                    };
                    animate();
                    await new Promise(resolve => setTimeout(resolve, duration));
                    break;
                    
                default:
                    await new Promise(resolve => setTimeout(resolve, duration));
            }
        }
        
        playDogSound(soundType) {
            // In a real implementation, we would play actual sounds
            // This is a placeholder for sound effects
            logger.info(`Playing dog sound: ${soundType}`);
            
            // If we had sound effects, we would play them here
            // For example:
            // const sound = new Audio(`/assets/sounds/${soundType}.mp3`);
            // sound.play();
        }
        
        /**
         * Actual LLM API call function - replace the simulation function with this
         * when you're ready to connect to a real API
         */
        async callLLMAPI(prompt) {
            try {
                const response = await fetch('/api/llm', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        systemPrompt: this.llmContext.systemPrompt,
                        messages: this.llmContext.memory,
                        // Add any API specific parameters here
                        temperature: 0.7,
                        max_tokens: 50
                    })
                });
                
                const data = await response.json();
                
                // Structure depends on the API you're using
                return data.choices[0].message.content;
            } catch (error) {
                console.error('Error calling LLM API:', error);
                return "tilts head with confusion";
            }
        }
        
        setupEventListeners() {
            window.addEventListener('resize', () => {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }
        
        render(timestamp, frame) {
            if (frame) {
                const referenceSpace = this.renderer.xr.getReferenceSpace();
                const session = this.renderer.xr.getSession();
                
                if (this.hitTestSourceRequested === false) {
                    session.requestReferenceSpace('viewer').then((referenceSpace) => {
                        session.requestHitTestSource({ space: referenceSpace }).then((source) => {
                            this.hitTestSource = source;
                        });
                    });
                    
                    session.addEventListener('end', () => {
                        this.hitTestSourceRequested = false;
                        this.hitTestSource = null;
                    });
                    
                    this.hitTestSourceRequested = true;
                }
                
                if (this.hitTestSource) {
                    const hitTestResults = frame.getHitTestResults(this.hitTestSource);
                    
                    if (hitTestResults.length) {
                        const hit = hitTestResults[0];
                        
                        this.reticle.visible = true;
                        this.reticle.matrix.fromArray(hit.getPose(referenceSpace).transform.matrix);
                        
                        if (this.statusEl.textContent === 'Looking for surface...') {
                            this.statusEl.textContent = 'Surface found! Click "Place Dog"';
                        }
                    } else {
                        this.reticle.visible = false;
                    }
                }
            }
            
            // Update animations
            this.updateDogAnimation();
            
            this.renderer.render(this.scene, this.camera);
        }
    }
    
    // Initialize the app when the page loads
    window.addEventListener('DOMContentLoaded', () => {
        // Log initial diagnostic info
        logger.info(`User Agent: ${navigator.userAgent}`);
        logger.info(`Screen: ${window.innerWidth}x${window.innerHeight}, pixel ratio: ${window.devicePixelRatio}`);
        logger.checkXRCapabilities();
        
        const app = new ARDogApp();
    });
    
    // Fallback 3D Mode for devices without AR support
    function startFallback3DMode() {
        logger.info('Starting fallback 3D mode');
        
        // Create simple 3D scene
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        // Set background color
        scene.background = new THREE.Color(0xaaaaaa);
        
        // Add lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);
        
        // Create renderer
        const renderer = new THREE.WebGLRenderer({ 
            canvas: document.getElementById('canvas'),
            antialias: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        
        // Position camera
        camera.position.z = 3.0; // Increased from 1.5 to zoom out more
        camera.position.y = 1.0; // Increased from 0.5 to look from a higher angle
        camera.lookAt(0, 0, 0); // Look at the center
        
        // Add ground plane
        const ground = new THREE.Mesh(
            new THREE.PlaneGeometry(10, 10),
            new THREE.MeshStandardMaterial({ color: 0x88aa88 })
        );
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -0.3;
        scene.add(ground);
        
        // Add orbit controls via mouse drag
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        
        document.addEventListener('mousedown', (e) => { 
            isDragging = true; 
            previousMousePosition = { x: e.clientX, y: e.clientY };
        });
        
        document.addEventListener('mouseup', () => { isDragging = false; });
        
        document.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaMove = {
                    x: e.clientX - previousMousePosition.x,
                    y: e.clientY - previousMousePosition.y
                };
                
                // Rotate dog container based on mouse movement
                if (dogContainer) {
                    dogContainer.rotation.y += deltaMove.x * 0.01;
                }
                
                previousMousePosition = { x: e.clientX, y: e.clientY };
            }
        });
        
        // Add touch support
        document.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                isDragging = true;
                previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            }
        });
        
        document.addEventListener('touchend', () => { isDragging = false; });
        
        document.addEventListener('touchmove', (e) => {
            if (isDragging && e.touches.length === 1) {
                const deltaMove = {
                    x: e.touches[0].clientX - previousMousePosition.x,
                    y: e.touches[0].clientY - previousMousePosition.y
                };
                
                // Rotate dog container based on touch movement
                if (dogContainer) {
                    dogContainer.rotation.y += deltaMove.x * 0.01;
                }
                
                previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                e.preventDefault(); // Prevent scrolling
            }
        });
        
        // Create container for dog (so we can rotate it)
        const dogContainer = new THREE.Group();
        scene.add(dogContainer);
        
        // Load dog model
        const loader = new THREE.GLTFLoader();
        let mixer = null;
        
        // Status update
        const statusEl = document.getElementById('status');
        statusEl.textContent = 'Loading dog model...';
        
        // Show UI buttons
        document.getElementById('talk').style.display = 'block';
        document.getElementById('pet').style.display = 'block';
        document.getElementById('throw-ball').style.display = 'block';
        
        // Try to load the dog model
        loader.load(
            '/assets/corgy.glb',
            (gltf) => {
                const dog = gltf.scene;
                dog.scale.set(0.15, 0.15, 0.15);
                
                // Center the model
                const box = new THREE.Box3().setFromObject(dog);
                const center = box.getCenter(new THREE.Vector3());
                dog.position.x += (dog.position.x - center.x);
                dog.position.y += (dog.position.y - center.y) + 0.3;
                dog.position.z += (dog.position.z - center.z);
                
                // Add to container
                dogContainer.add(dog);
                
                // Setup animations
                if (gltf.animations && gltf.animations.length) {
                    mixer = new THREE.AnimationMixer(dog);
                    const action = mixer.clipAction(gltf.animations[0]);
                    action.play();
                }
                
                statusEl.textContent = '3D Mode Active - Drag to rotate view';
                logger.info('Dog model loaded in 3D mode');
            },
            (xhr) => {
                const percent = Math.floor(xhr.loaded / xhr.total * 100);
                statusEl.textContent = `Loading dog model: ${percent}%`;
            },
            (error) => {
                console.error('Error loading dog model:', error);
                statusEl.textContent = 'Error loading dog. Using fallback.';
                
                // Create a simple dog placeholder
                createPrimitiveDog(dogContainer);
            }
        );
        
        // Clock for animations
        const clock = new THREE.Clock();
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Update animations
            if (mixer) {
                mixer.update(clock.getDelta());
            }
            
            renderer.render(scene, camera);
        }
        
        // Start animation loop
        animate();
        
        // Connect interaction buttons with behavior interpreter
        document.getElementById('talk').addEventListener('click', () => {
            document.getElementById('speech-input').style.display = 'block';
            document.getElementById('speech-input').focus();
        });
        
        document.getElementById('speech-input').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                const text = document.getElementById('speech-input').value.trim();
                if (text) {
                    statusEl.textContent = `You: ${text}`;
                    document.getElementById('speech-input').value = '';
                    document.getElementById('speech-input').style.display = 'none';
                    
                    // Show dog thinking
                    document.getElementById('thinking').style.display = 'block';
                    
                    // Simulate response after delay
                    setTimeout(() => {
                        document.getElementById('thinking').style.display = 'none';
                        const responses = [
                            "wags tail excitedly",
                            "tilts head curiously",
                            "barks happily",
                            "looks at you with interest"
                        ];
                        const response = responses[Math.floor(Math.random() * responses.length)];
                        statusEl.textContent = `Dog: ${response}`;
                        
                        // Interpret and execute dog behavior based on AI response
                        interpretAndExecute3DModeBehavior(response, dogContainer, mixer);
                    }, 1500);
                }
            }
        });
        
        document.getElementById('pet').addEventListener('click', () => {
            statusEl.textContent = "You pet the dog";
            
            // Show dog thinking
            document.getElementById('thinking').style.display = 'block';
            
            // Simulate response after delay
            setTimeout(() => {
                document.getElementById('thinking').style.display = 'none';
                const response = "wags tail happily and leans into the pets";
                statusEl.textContent = `Dog: ${response}`;
                
                // Interpret and execute dog behavior
                interpretAndExecute3DModeBehavior(response, dogContainer, mixer);
            }, 1000);
        });
        
        document.getElementById('throw-ball').addEventListener('click', () => {
            statusEl.textContent = "You threw a ball";
            
            // Create a ball if it doesn't exist
            let ball = scene.getObjectByName("ball");
            if (!ball) {
                ball = new THREE.Mesh(
                    new THREE.SphereGeometry(0.05, 16, 16),
                    new THREE.MeshStandardMaterial({ color: 0xff0000 })
                );
                ball.name = "ball";
                scene.add(ball);
            }
            
            // Position the ball
            ball.position.set(0, 0.3, 0);
            ball.visible = true;
            
            // Animate the ball throw
            const startPos = ball.position.clone();
            const endPos = new THREE.Vector3(
                (Math.random() - 0.5) * 2,
                0.05,
                (Math.random() - 0.5) * 2
            );
            
            const startTime = Date.now();
            
            function animateBall() {
                const progress = (Date.now() - startTime) / 1000; // 1 second animation
                
                if (progress < 1) {
                    // Parabolic arc
                    const t = progress;
                    ball.position.x = startPos.x + (endPos.x - startPos.x) * t;
                    ball.position.z = startPos.z + (endPos.z - startPos.z) * t;
                    ball.position.y = startPos.y + 0.5 * Math.sin(Math.PI * t); // Arc height
                    
                    requestAnimationFrame(animateBall);
                } else {
                    ball.position.copy(endPos);
                    
                    // Show dog thinking
                    document.getElementById('thinking').style.display = 'block';
                    
                    // Dog responds after the ball lands
                    setTimeout(() => {
                        document.getElementById('thinking').style.display = 'none';
                        const response = "barks excitedly and chases after the ball";
                        statusEl.textContent = `Dog: ${response}`;
                        
                        // Interpret and execute dog behavior
                        interpretAndExecute3DModeBehavior(response, dogContainer, mixer, ball);
                    }, 1000);
                }
            }
            
            animateBall();
        });
        
        // Add a separate behavior interpreter for 3D mode
        function interpretAndExecute3DModeBehavior(response, dogModel, animMixer, ball) {
            logger.info(`3D Mode: Interpreting behavior: "${response}"`);
            
            // For GLTF model with animation mixer
            if (animMixer && animMixer._actions && animMixer._actions.length > 0) {
                // Use the animation mixer
                if (response.includes('wag') || response.includes('excit') || response.includes('happy')) {
                    const action = animMixer.clipAction(animMixer._actions[0].getClip());
                    action.setEffectiveTimeScale(1.5); // Speed up animation for excitement
                    action.play();
                } else if (response.includes('bark') || response.includes('jump')) {
                    const action = animMixer.clipAction(animMixer._actions[0].getClip());
                    action.setEffectiveTimeScale(2.0); // Even faster for barking/jumping
                    action.play();
                } else {
                    const action = animMixer.clipAction(animMixer._actions[0].getClip());
                    action.setEffectiveTimeScale(1.0); // Normal speed for other actions
                    action.play();
                }
            } 
            // For enhanced primitive dog model
            else if (dogModel && dogModel.playAnimation) {
                // Parse the response and play appropriate animations
                if (response.includes('wag') || response.includes('tail')) {
                    dogModel.playAnimation('waggingTail', 3000); // Wag tail for 3 seconds
                    
                    // Chain animations - return to idle after wagging
                    setTimeout(() => {
                        dogModel.playAnimation('idle');
                    }, 3000);
                }
                else if (response.includes('run') || response.includes('chase')) {
                    // If there's a ball to chase
                    if (ball && ball.visible) {
                        dogModel.playAnimation('running', 2000);
                        
                        // Move toward the ball
                        const startPos = dogModel.position.clone();
                        const targetPos = ball.position.clone();
                        
                        // Animate position change
                        const moveStart = Date.now();
                        const moveAnimation = () => {
                            const elapsed = Date.now() - moveStart;
                            if (elapsed < 2000) {
                                const t = elapsed / 2000;
                                
                                // Move dog toward ball
                                dogModel.position.x = startPos.x + (targetPos.x - startPos.x) * t;
                                dogModel.position.z = startPos.z + (targetPos.z - startPos.z) * t;
                                
                                // Look at ball
                                const lookAt = new THREE.Vector3(targetPos.x, dogModel.position.y, targetPos.z);
                                dogModel.lookAt(lookAt);
                                
                                requestAnimationFrame(moveAnimation);
                            } else {
                                // Reached the ball
                                if (ball) ball.visible = false;
                                
                                // Wag tail after getting the ball
                                dogModel.playAnimation('waggingTail', 2000);
                                
                                // Return to idle
                                setTimeout(() => {
                                    dogModel.playAnimation('idle');
                                }, 2000);
                            }
                        };
                        
                        moveAnimation();
                    } else {
                        // Just run in place if no ball
                        dogModel.playAnimation('running', 2500);
                        
                        // Return to idle after running
                        setTimeout(() => {
                            dogModel.playAnimation('idle');
                        }, 2500);
                    }
                }
                else if (response.includes('walk')) {
                    dogModel.playAnimation('walking', 3000);
                    
                    // Return to idle after walking
                    setTimeout(() => {
                        dogModel.playAnimation('idle');
                    }, 3000);
                }
                else if (response.includes('bark')) {
                    dogModel.playAnimation('barking', 1500);
                    
                    // Return to idle after barking
                    setTimeout(() => {
                        dogModel.playAnimation('idle');
                    }, 1500);
                }
                else if (response.includes('tilt') || response.includes('curious')) {
                    dogModel.playAnimation('headTilt', 2000);
                    
                    // Return to idle after head tilt
                    setTimeout(() => {
                        dogModel.playAnimation('idle');
                    }, 2000);
                }
                else {
                    // Default animation
                    dogModel.playAnimation('idle');
                }
            }
            // Basic primitive dog (old version) or simple behavior for any model
            else if (dogModel) {
                if (response.includes('wag') || response.includes('excit') || response.includes('happy')) {
                    // Simple rotation animation for basic model
                    const startTime = Date.now();
                    const rotateAnimation = () => {
                        const elapsed = Date.now() - startTime;
                        if (elapsed < 2000) {
                            dogModel.rotation.y += 0.05;
                            requestAnimationFrame(rotateAnimation);
                        }
                    };
                    rotateAnimation();
                }
            }
        }
    }
    
    // Modify the createPrimitiveDog function for 3D mode to support more behaviors
    function createPrimitiveDog(container) {
        // Body
        const body = new THREE.Mesh(
            new THREE.CapsuleGeometry(0.06, 0.12, 4, 8),
            new THREE.MeshStandardMaterial({ color: 0xA0522D })
        );
        body.rotation.z = Math.PI / 2;
        body.position.y = 0.12;
        container.add(body);
        
        // Head
        const head = new THREE.Mesh(
            new THREE.SphereGeometry(0.045, 16, 16),
            new THREE.MeshStandardMaterial({ color: 0x8B4513 })
        );
        head.position.set(0.09, 0.16, 0);
        container.add(head);
        
        // Eyes
        const eyeGeometry = new THREE.SphereGeometry(0.01, 8, 8);
        const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
        
        const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
        leftEye.position.set(0.12, 0.18, 0.025);
        container.add(leftEye);
        
        const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
        rightEye.position.set(0.12, 0.18, -0.025);
        container.add(rightEye);
        
        // Nose
        const nose = new THREE.Mesh(
            new THREE.SphereGeometry(0.012, 8, 8),
            new THREE.MeshBasicMaterial({ color: 0x000000 })
        );
        nose.position.set(0.14, 0.15, 0);
        container.add(nose);
        
        // Legs
        const legGeometry = new THREE.CylinderGeometry(0.012, 0.012, 0.06, 8);
        const legMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
        
        const legs = [];
        const legPositions = [
            [-0.04, 0.1, 0.04],  // back left
            [-0.04, 0.1, -0.04], // back right
            [0.04, 0.1, 0.04],   // front left
            [0.04, 0.1, -0.04]   // front right
        ];
        
        legPositions.forEach((pos, i) => {
            const leg = new THREE.Mesh(legGeometry, legMaterial);
            leg.position.set(...pos);
            leg.name = `leg${i}`;
            container.add(leg);
            legs.push(leg);
        });
        
        // Tail
        const tail = new THREE.Mesh(
            new THREE.CylinderGeometry(0.01, 0.003, 0.06, 8),
            new THREE.MeshStandardMaterial({ color: 0x8B4513 })
        );
        tail.position.set(-0.1, 0.12, 0);
        tail.rotation.z = Math.PI / 4;
        container.add(tail);
        
        // Move entire container up to clear the ground
        container.position.y = 0.05;
        
        // Animation variables
        let currentAnimation = 'idle';
        let animationStartTime = Date.now();
        let walkDirection = new THREE.Vector3(0, 0, 0);
        
        // Animation states
        const animations = {
            idle: {
                duration: 2000,
                update: (t) => {
                    // Gentle breathing
                    body.position.y = 0.12 + Math.sin(t * Math.PI) * 0.006;
                    head.position.y = 0.16 + Math.sin(t * Math.PI) * 0.006;
                    
                    // Subtle tail movement
                    tail.rotation.z = Math.PI / 4 + Math.sin(t * Math.PI) * 0.05;
                }
            },
            walking: {
                duration: 1000,
                update: (t) => {
                    const cycle = t * Math.PI * 2;
                    
                    // Diagonal leg pairs move together (realistic quadruped walking)
                    // Front left and back right move together, front right and back left move together
                    legs[0].position.y = 0.1 + Math.max(0, Math.sin(cycle)) * 0.02;         // back left
                    legs[3].position.y = 0.1 + Math.max(0, Math.sin(cycle)) * 0.02;         // front right
                    legs[1].position.y = 0.1 + Math.max(0, Math.sin(cycle + Math.PI)) * 0.02; // back right
                    legs[2].position.y = 0.1 + Math.max(0, Math.sin(cycle + Math.PI)) * 0.02; // front left
                    
                    // Add leg forward/backward motion
                    legs[0].position.x = legPositions[0][0] + Math.sin(cycle) * 0.01;
                    legs[1].position.x = legPositions[1][0] + Math.sin(cycle + Math.PI) * 0.01;
                    legs[2].position.x = legPositions[2][0] + Math.sin(cycle + Math.PI) * 0.01;
                    legs[3].position.x = legPositions[3][0] + Math.sin(cycle) * 0.01;
                    
                    // Body moves slightly up and down with the steps
                    body.position.y = 0.12 + Math.sin(cycle * 2) * 0.005;
                    
                    // Head bobs slightly with the walk cycle
                    head.position.y = 0.16 + Math.sin(cycle * 2) * 0.008;
                    
                    // Tail swings with the walk
                    tail.rotation.z = Math.PI / 4 + Math.sin(cycle) * 0.1;
                }
            },
            waggingTail: {
                duration: 400, // Faster for excited tail wagging
                update: (t) => {
                    const cycle = t * Math.PI * 2;
                    
                    // Energetic tail wagging (faster and wider movement)
                    tail.rotation.z = Math.PI / 4 + Math.sin(cycle * 2) * 0.4;
                    tail.rotation.y = Math.sin(cycle * 4) * 0.2;
                    
                    // Dog slightly shifts weight from side to side
                    body.rotation.z = Math.PI / 2 + Math.sin(cycle) * 0.03;
                    
                    // Subtle happy bouncing
                    body.position.y = 0.12 + Math.abs(Math.sin(cycle * 2)) * 0.01;
                    head.position.y = 0.16 + Math.abs(Math.sin(cycle * 2)) * 0.01;
                }
            },
            running: {
                duration: 600, // Faster for running
                update: (t) => {
                    const cycle = t * Math.PI * 3; // Faster cycle for running
                    
                    // Exaggerated leg movements (higher steps)
                    legs[0].position.y = 0.1 + Math.max(0, Math.sin(cycle)) * 0.04;
                    legs[3].position.y = 0.1 + Math.max(0, Math.sin(cycle)) * 0.04;
                    legs[1].position.y = 0.1 + Math.max(0, Math.sin(cycle + Math.PI)) * 0.04;
                    legs[2].position.y = 0.1 + Math.max(0, Math.sin(cycle + Math.PI)) * 0.04;
                    
                    // Forward/backward leg motion
                    legs[0].position.x = legPositions[0][0] + Math.sin(cycle) * 0.02;
                    legs[1].position.x = legPositions[1][0] + Math.sin(cycle + Math.PI) * 0.02;
                    legs[2].position.x = legPositions[2][0] + Math.sin(cycle + Math.PI) * 0.02;
                    legs[3].position.x = legPositions[3][0] + Math.sin(cycle) * 0.02;
                    
                    // More pronounced body movement
                    body.position.y = 0.12 + Math.sin(cycle * 2) * 0.01;
                    
                    // Head bobs more with running
                    head.position.y = 0.16 + Math.sin(cycle * 2) * 0.015;
                    
                    // Tail streams behind when running
                    tail.rotation.z = Math.PI / 5 + Math.sin(cycle) * 0.1;
                }
            },
            barking: {
                duration: 300, // Quick for barking
                update: (t) => {
                    const cycle = t * Math.PI * 2;
                    
                    // Head moves forward slightly when barking
                    head.position.x = 0.09 + Math.abs(Math.sin(cycle * 4)) * 0.01;
                    head.position.y = 0.16 + Math.sin(cycle * 4) * 0.005;
                    
                    // Mouth would open here if we had a separate mouth model
                    
                    // Slight body movement
                    body.position.y = 0.12 + Math.abs(Math.sin(cycle * 4)) * 0.005;
                }
            },
            headTilt: {
                duration: 1500,
                update: (t) => {
                    // Tilt head to one side
                    if (t < 0.3) {
                        // Initial tilt motion
                        head.rotation.z = t/0.3 * 0.3;
                    } else if (t > 0.7) {
                        // Return to normal
                        head.rotation.z = Math.max(0, 0.3 - (t-0.7)/0.3 * 0.3);
                    } else {
                        // Hold the tilt
                        head.rotation.z = 0.3;
                    }
                    
                    // Subtle ear movement would go here if we had ear models
                    
                    // Eyes look up slightly
                    leftEye.position.y = 0.18 + t * 0.005;
                    rightEye.position.y = 0.18 + t * 0.005;
                }
            }
        };
        
        // Function to play a specific animation
        function playAnimation(name, duration = null) {
            if (animations[name]) {
                currentAnimation = name;
                animationStartTime = Date.now();
                
                // Optional custom duration
                if (duration) animations[name].customDuration = duration;
                else delete animations[name].customDuration;
                
                // Reset positions when changing animations
                resetPositions();
            }
        }
        
        // Reset all body parts to default positions
        function resetPositions() {
            // Reset legs
            legs.forEach((leg, i) => {
                leg.position.set(...legPositions[i]);
            });
            
            // Reset head rotation
            head.rotation.set(0, 0, 0);
            
            // Reset eye positions
            leftEye.position.set(0.12, 0.18, 0.025);
            rightEye.position.set(0.12, 0.18, -0.025);
            
            // Reset head position
            head.position.set(0.09, 0.16, 0);
            
            // Reset body
            body.position.y = 0.12;
            body.rotation.z = Math.PI / 2;
            
            // Reset tail
            tail.rotation.z = Math.PI / 4;
            tail.rotation.y = 0;
        }
        
        // Main animation loop
        function animateDog() {
            requestAnimationFrame(animateDog);
            
            const now = Date.now();
            const animation = animations[currentAnimation];
            
            if (animation) {
                const duration = animation.customDuration || animation.duration;
                const elapsed = now - animationStartTime;
                const t = (elapsed % duration) / duration;
                
                animation.update(t);
            }
        }
        
        // Start animation loop
        animateDog();
        
        // Make animations accessible
        container.animations = animations;
        container.playAnimation = playAnimation;
        
        // Default to idle animation
        playAnimation('idle');
        
        logger.info('Enhanced primitive dog created for fallback');
        document.getElementById('status').textContent = '3D Mode Active - Drag to rotate view';
    }
    </script>
</body>
</html>
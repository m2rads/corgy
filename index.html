<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>AR AI Dog</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        #ui {
            position: absolute;
            bottom: 20px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: center;
            pointer-events: none;
        }
        .button {
            background: rgba(255, 255, 255, 0.7);
            border: none;
            border-radius: 30px;
            padding: 12px 20px;
            margin: 0 10px;
            font-weight: bold;
            pointer-events: auto;
        }
        /* New styles for fallback mode */
        #fallback-mode {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            display: none;
        }
        #fallback-button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            margin-top: 15px;
            cursor: pointer;
            font-weight: bold;
        }
        /* End new styles */
        #status {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 10px;
            border-radius: 5px;
            max-width: 80%;
        }
        #speech-input {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            padding: 12px;
            border-radius: 30px;
            border: none;
            background: rgba(255, 255, 255, 0.9);
            display: none;
            pointer-events: auto;
        }
        .thinking {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px 20px;
            border-radius: 10px;
            display: none;
        }
        /* Debug panel styles */
        #debug-panel {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.8);
            color: lime;
            font-family: monospace;
            font-size: 10px;
            max-height: 30%;
            overflow-y: auto;
            padding: 10px;
            display: none;
        }
        #debug-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="status">Looking for surface...</div>
    <div id="thinking" class="thinking">Dog is thinking...</div>
    <input type="text" id="speech-input" placeholder="Say something to the dog...">
    <div id="ui">
        <button id="start-ar" class="button">Start AR</button>
        <button id="place-dog" class="button" style="display: none;">Place Dog</button>
        <button id="talk" class="button" style="display: none;">Talk</button>
        <button id="pet" class="button" style="display: none;">Pet</button>
        <button id="throw-ball" class="button" style="display: none;">Throw Ball</button>
    </div>
    
    <!-- Debug Tools -->
    <button id="debug-toggle">Show Debug</button>
    <div id="debug-panel"></div>

    <!-- Fallback Mode UI -->
    <div id="fallback-mode">
        <h3>AR Not Supported</h3>
        <p>Your device or browser doesn't support WebXR for AR.</p>
        <p>You can still view the dog in 3D mode instead.</p>
        <button id="fallback-button">View in 3D Mode</button>
    </div>

    <!-- Import libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r132/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/DRACOLoader.js"></script>
    <!-- Add WebXR polyfills for better iOS support -->
    <script src="https://unpkg.com/webxr-polyfill@latest/build/webxr-polyfill.js"></script>

    <script>
    // Initialize WebXR polyfill first
    const polyfill = new WebXRPolyfill({
        // Specific options for iOS
        allowCardboardOnDesktop: true,
        enableLegacyWebVR: true
    });
    
    // Debug logger
    const logger = {
        logs: [],
        maxLogs: 100,
        
        log: function(message, type = 'info') {
            const timestamp = new Date().toISOString().substring(11, 23);
            const entry = `${timestamp} [${type.toUpperCase()}] ${message}`;
            this.logs.unshift(entry);
            
            // Trim log if needed
            if (this.logs.length > this.maxLogs) {
                this.logs.pop();
            }
            
            // Update debug panel if visible
            this.updatePanel();
            
            // Also log to console
            console.log(entry);
            
            // Send to server for logging important events
            if (type === 'error' || type === 'warn') {
                this.sendToServer(entry, type);
            }
        },
        
        info: function(message) {
            this.log(message, 'info');
        },
        
        warn: function(message) {
            this.log(message, 'warn');
        },
        
        error: function(message, error) {
            let errorDetails = message;
            if (error) {
                errorDetails += `: ${error.message || error}`;
                console.error(error);
            }
            this.log(errorDetails, 'error');
        },
        
        updatePanel: function() {
            const panel = document.getElementById('debug-panel');
            if (panel) {
                panel.innerHTML = this.logs.join('<br>');
            }
        },
        
        sendToServer: function(message, type) {
            try {
                fetch('/api/log', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        message,
                        type,
                        userAgent: navigator.userAgent,
                        timestamp: new Date().toISOString()
                    })
                }).catch(e => {
                    console.error('Failed to send log to server', e);
                    // Don't worry about server logging failing
                });
            } catch (e) {
                console.error('Error sending log to server', e);
                // Continue even if server logging fails
            }
        },
        
        checkXRCapabilities: function() {
            this.info('Checking XR capabilities...');
            
            // Try to check AR capabilities on server but don't rely on response
            fetch('/api/check-ar')
                .then(res => res.json())
                .then(data => {
                    this.info(`AR check endpoint response: ${JSON.stringify(data.message)}`);
                })
                .catch(err => {
                    this.info('AR check endpoint failed - continuing in offline mode');
                });
                
            // Check navigator.xr
            if (!navigator.xr) {
                this.error('WebXR API not available on this browser');
                return false;
            } else {
                this.info('WebXR API is available');
            }
            
            // Return results of basic check
            return !!navigator.xr;
        }
    };
    
    // Initialize debug panel
    document.getElementById('debug-toggle').addEventListener('click', function() {
        const panel = document.getElementById('debug-panel');
        if (panel.style.display === 'none' || !panel.style.display) {
            panel.style.display = 'block';
            this.textContent = 'Hide Debug';
        } else {
            panel.style.display = 'none';
            this.textContent = 'Show Debug';
        }
    });

    // Add fallback mode functionality
    document.getElementById('fallback-button').addEventListener('click', function() {
        document.getElementById('fallback-mode').style.display = 'none';
        startFallback3DMode();
    });

    // Main Application
    class ARDogApp {
        constructor() {
            // Scene setup
            this.canvas = document.getElementById('canvas');
            this.scene = new THREE.Scene();
            this.camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);
            
            // Renderer with iOS-friendly settings
            this.renderer = new THREE.WebGLRenderer({ 
                canvas: this.canvas, 
                antialias: true, 
                alpha: true,
                powerPreference: "high-performance",
                precision: "highp"
            });
            this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limit pixel ratio for performance
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.renderer.xr.enabled = true;
            
            // Extra debugging for iOS
            logger.info(`Using WebGL Renderer: ${this.renderer.getContext().getParameter(this.renderer.getContext().VERSION)}`);
            logger.info(`Renderer pixel ratio: ${this.renderer.getPixelRatio()}`);
            
            // AR elements
            this.hitTestSource = null;
            this.hitTestSourceRequested = false;
            this.reticle = new THREE.Mesh(
                new THREE.RingGeometry(0.15, 0.2, 32).rotateX(-Math.PI / 2),
                new THREE.MeshBasicMaterial()
            );
            this.reticle.matrixAutoUpdate = false;
            this.reticle.visible = false;
            this.scene.add(this.reticle);
            
            // Dog model and variables
            this.dog = null;
            this.dogPlaced = false;
            this.dogAnimations = {};
            this.currentAnimation = null;
            this.mixer = null;
            this.clock = new THREE.Clock();
            this.dogState = {
                mood: "neutral", // neutral, happy, sad, excited, tired
                lastInteractions: [],
                energy: 100,
                memory: {}
            };
            
            // LLM context
            this.llmContext = {
                currentPrompt: "",
                systemPrompt: `You are an AI dog in an augmented reality experience. You behave just like a real friendly dog would. 
                Your responses should be short actions the dog would take, using only a few words.
                Never speak in full sentences, just give the dog's actions and maybe a sound (like "woof!" or "whines").
                For example: "wags tail excitedly", "tilts head curiously", "jumps up and down, barking", "lies down and looks sad".
                You should never talk like a human - remember you are a dog!`,
                memory: []
            };
            
            // Physics objects
            this.ball = null;
            
            // UI elements
            this.statusEl = document.getElementById('status');
            this.startARButton = document.getElementById('start-ar');
            this.placeDogButton = document.getElementById('place-dog');
            this.talkButton = document.getElementById('talk');
            this.petButton = document.getElementById('pet');
            this.throwBallButton = document.getElementById('throw-ball');
            this.speechInput = document.getElementById('speech-input');
            this.thinkingEl = document.getElementById('thinking');
            
            // Initialize
            this.setupLighting();
            this.setupEventListeners();
            this.initARButton();
        }
        
        setupLighting() {
            const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
            light.position.set(0.5, 1, 0.25);
            this.scene.add(light);
        }
        
        initARButton() {
            this.startARButton.addEventListener('click', () => {
                logger.info('Start AR button clicked');
                // Add a user gesture handler for iOS - Safari requires user gesture
                this.startARSession();
            });
        }
        
        startARSession() {
            logger.info('Starting AR session with WebXR version: ' + (navigator.xr ? 'Available' : 'Not available'));
            
            // Make sure this is being called from a user gesture for iOS Safari
            if (!navigator.xr) {
                logger.error('WebXR API not available in this browser');
                
                const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
                if (isIOS) {
                    logger.info('iOS device detected, attempting WebXR polyfill');
                    // Force showing the AR button on iOS even if navigator.xr is not detected
                    // The WebXR polyfill might make it work
                    this.statusEl.innerHTML = 'Using WebXR polyfill. If this does not work, your device may not support AR.';
                    
                    // Try to initialize AR anyway - the polyfill might handle it
                    this.tryInitializeAR();
                } else {
                    this.statusEl.innerHTML = 'AR not supported on this device/browser.';
                    // Show fallback mode
                    document.getElementById('fallback-mode').style.display = 'block';
                }
                return;
            }
            
            this.tryInitializeAR();
        }
        
        tryInitializeAR() {
            logger.info('Trying to initialize AR');
            
            if (typeof navigator.xr.isSessionSupported !== 'function') {
                logger.error('isSessionSupported is not a function - polyfill may not be working correctly');
                this.statusEl.innerHTML = 'WebXR API not fully supported on this browser.';
                // Show fallback mode
                document.getElementById('fallback-mode').style.display = 'block';
                return;
            }
            
            navigator.xr.isSessionSupported('immersive-ar')
                .then((supported) => {
                    if (supported) {
                        logger.info('immersive-ar is supported, requesting session');
                        
                        // Use minimal required features for iOS compatibility
                        const sessionInit = { 
                            requiredFeatures: ['hit-test'],
                            optionalFeatures: ['dom-overlay'],
                        };
                        
                        // Add dom-overlay only if supported
                        if (sessionInit.optionalFeatures.includes('dom-overlay')) {
                            sessionInit.domOverlay = { root: document.body };
                        }
                        
                        navigator.xr.requestSession('immersive-ar', sessionInit)
                            .then(session => {
                                logger.info('AR session created successfully');
                                this.onSessionStarted(session);
                            })
                            .catch(error => {
                                logger.error('Failed to start AR session', error);
                                
                                if (error.message.includes('permission')) {
                                    this.statusEl.textContent = 'Camera permission denied. Please allow camera access.';
                                } else {
                                    this.statusEl.textContent = `AR session failed: ${error.message || error}`;
                                }
                                // Show fallback mode
                                document.getElementById('fallback-mode').style.display = 'block';
                            });
                    } else {
                        logger.error('immersive-ar not supported on this device');
                        this.statusEl.innerHTML = 'AR not supported on this device. Your device might not have AR capabilities.';
                        // Show fallback mode
                        document.getElementById('fallback-mode').style.display = 'block';
                    }
                })
                .catch(error => {
                    logger.error('Error checking AR support', error);
                    this.statusEl.textContent = `Error checking AR support: ${error.message || error}`;
                    // Show fallback mode
                    document.getElementById('fallback-mode').style.display = 'block';
                });
        }
        
        onSessionStarted(session) {
            logger.info('AR session started, configuring');
            this.startARButton.style.display = 'none';
            this.placeDogButton.style.display = 'block';
            
            this.renderer.xr.setReferenceSpaceType('local');
            this.renderer.xr.setSession(session);
            
            session.addEventListener('end', this.onSessionEnded.bind(this));
            
            this.placeDogButton.addEventListener('click', this.placeDog.bind(this));
            this.talkButton.addEventListener('click', this.activateSpeechInput.bind(this));
            this.petButton.addEventListener('click', () => this.interactWithDog('pet'));
            this.throwBallButton.addEventListener('click', () => this.throwBall());
            
            this.speechInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    const text = this.speechInput.value.trim();
                    if (text) {
                        this.talkToDog(text);
                        this.speechInput.value = '';
                        this.speechInput.style.display = 'none';
                    }
                }
            });
            
            this.loadDogModel();
            
            this.renderer.setAnimationLoop(this.render.bind(this));
        }
        
        onSessionEnded() {
            this.startARButton.style.display = 'block';
            this.placeDogButton.style.display = 'none';
            this.talkButton.style.display = 'none';
            this.petButton.style.display = 'none';
            this.throwBallButton.style.display = 'none';
            this.renderer.setAnimationLoop(null);
        }
        
        async loadDogModel() {
            this.statusEl.textContent = 'Loading dog model...';
            
            // Load the corgy.glb model using GLTFLoader
            const loader = new THREE.GLTFLoader();
            
            try {
                const gltf = await new Promise((resolve, reject) => {
                    loader.load(
                        '/assets/corgy.glb',  // Path to the model
                        resolve,
                        (xhr) => {
                            console.log((xhr.loaded / xhr.total * 100) + '% loaded');
                        },
                        reject
                    );
                });
                
                this.dog = gltf.scene;
                
                // Scale if needed (adjust based on your model size)
                this.dog.scale.set(0.15, 0.15, 0.15);
                
                // Center the model if needed
                const box = new THREE.Box3().setFromObject(this.dog);
                const center = box.getCenter(new THREE.Vector3());
                this.dog.position.x += (this.dog.position.x - center.x);
                this.dog.position.y += (this.dog.position.y - center.y) + 0.3;
                this.dog.position.z += (this.dog.position.z - center.z);
                
                // Setup animations if your model has them
                if (gltf.animations && gltf.animations.length) {
                    this.mixer = new THREE.AnimationMixer(this.dog);
                    
                    // Store animations
                    gltf.animations.forEach(clip => {
                        const action = this.mixer.clipAction(clip);
                        this.dogAnimations[clip.name] = action;
                    });
                    
                    // Define animation mappings
                    if (!this.dogAnimations['idle'] && gltf.animations.length > 0) {
                        // If no specific 'idle' animation, use the first one as default
                        this.dogAnimations['idle'] = this.mixer.clipAction(gltf.animations[0]);
                    }
                    
                    // Check for other common animations and create mappings
                    const animationNames = gltf.animations.map(a => a.name.toLowerCase());
                    
                    if (!this.dogAnimations['walking']) {
                        // Try to find walking animation
                        const walkIndex = animationNames.findIndex(n => 
                            n.includes('walk') || n.includes('run') || n.includes('trot'));
                        if (walkIndex >= 0) {
                            this.dogAnimations['walking'] = this.mixer.clipAction(gltf.animations[walkIndex]);
                        } else {
                            // Fallback to idle
                            this.dogAnimations['walking'] = this.dogAnimations['idle'];
                        }
                    }
                    
                    if (!this.dogAnimations['excited']) {
                        // Try to find excited animation
                        const excitedIndex = animationNames.findIndex(n => 
                            n.includes('jump') || n.includes('bark') || n.includes('excited'));
                        if (excitedIndex >= 0) {
                            this.dogAnimations['excited'] = this.mixer.clipAction(gltf.animations[excitedIndex]);
                        } else {
                            // Fallback to idle
                            this.dogAnimations['excited'] = this.dogAnimations['idle'];
                        }
                    }
                    
                    // Play default animation
                    this.playDogAnimation('idle');
                }
                
                this.dog.visible = false;  // Hide until placed
                this.scene.add(this.dog);
                
                this.statusEl.textContent = 'Dog model loaded! Find a surface to place it.';
                
            } catch (error) {
                console.error('Error loading dog model:', error);
                this.statusEl.textContent = 'Error loading dog model. Using fallback.';
                
                // Fallback to primitive dog if model loading fails
                this.createPrimitiveDog();
            }
        }
        
        createPrimitiveDog() {
            // Create a simple dog placeholder using primitives
            const dogGroup = new THREE.Group();
            
            // Body
            const body = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.06, 0.12, 4, 8),
                new THREE.MeshStandardMaterial({ color: 0xA0522D })
            );
            body.rotation.z = Math.PI / 2;
            body.position.y = 0.12;
            dogGroup.add(body);
            
            // Head
            const head = new THREE.Mesh(
                new THREE.SphereGeometry(0.045, 16, 16),
                new THREE.MeshStandardMaterial({ color: 0x8B4513 })
            );
            head.position.set(0.09, 0.16, 0);
            dogGroup.add(head);
            
            // Eyes
            const eyeGeometry = new THREE.SphereGeometry(0.01, 8, 8);
            const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(0.12, 0.18, 0.025);
            dogGroup.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.12, 0.18, -0.025);
            dogGroup.add(rightEye);
            
            // Nose
            const nose = new THREE.Mesh(
                new THREE.SphereGeometry(0.012, 8, 8),
                new THREE.MeshBasicMaterial({ color: 0x000000 })
            );
            nose.position.set(0.14, 0.15, 0);
            dogGroup.add(nose);
            
            // Legs
            const legGeometry = new THREE.CylinderGeometry(0.012, 0.012, 0.06, 8);
            const legMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            
            const legs = [];
            const legPositions = [
                [-0.04, 0.1, 0.04],
                [-0.04, 0.1, -0.04],
                [0.04, 0.1, 0.04],
                [0.04, 0.1, -0.04]
            ];
            
            legPositions.forEach(pos => {
                const leg = new THREE.Mesh(legGeometry, legMaterial);
                leg.position.set(...pos);
                dogGroup.add(leg);
                legs.push(leg);
            });
            
            // Tail
            const tail = new THREE.Mesh(
                new THREE.CylinderGeometry(0.01, 0.003, 0.06, 8),
                new THREE.MeshStandardMaterial({ color: 0x8B4513 })
            );
            tail.position.set(-0.1, 0.12, 0);
            tail.rotation.z = Math.PI / 4;
            dogGroup.add(tail);
            
            // Add to scene
            this.dog = dogGroup;
            this.scene.add(this.dog);
            
            // Define primitive animations
            this.dogAnimations = {
                idle: { duration: 2000, onUpdate: (t) => {
                    const y = 0.05 * Math.sin(t * Math.PI);
                    body.position.y = 0.12 + y * 0.02;
                    head.position.y = 0.16 + y * 0.02;
                }},
                walking: { duration: 1000, onUpdate: (t) => {
                    const cycle = t * Math.PI * 2;
                    legs.forEach((leg, i) => {
                        leg.position.y = 0.06 + Math.abs(Math.sin(cycle + i * Math.PI/2)) * 0.005;
                    });
                    body.position.y = 0.12 + Math.sin(cycle * 2) * 0.002;
                }},
                excited: { duration: 800, onUpdate: (t) => {
                    const cycle = t * Math.PI * 4;
                    body.position.y = 0.12 + Math.abs(Math.sin(cycle)) * 0.01;
                    head.position.y = 0.16 + Math.abs(Math.sin(cycle)) * 0.01;
                    tail.rotation.z = Math.PI / 4 + Math.sin(cycle * 2) * 0.05;
                }},
                sleeping: { duration: 3000, onUpdate: (t) => {
                    const breathing = Math.sin(t * Math.PI) * 0.002;
                    body.scale.y = 1 + breathing;
                }}
            };
            
            // Override the updateDogAnimation method for primitive animations
            this.updateDogAnimationOriginal = this.updateDogAnimation;
            this.updateDogAnimation = () => {
                if (!this.currentAnimation || !this.dog) return;
                
                const elapsed = Date.now() - this.currentAnimation.startTime;
                const t = (elapsed % this.currentAnimation.duration) / this.currentAnimation.duration;
                
                this.currentAnimation.onUpdate(t);
            };
            
            // Override the playDogAnimation method for primitive animations
            this.playDogAnimationOriginal = this.playDogAnimation;
            this.playDogAnimation = (name) => {
                this.currentAnimation = {
                    name,
                    startTime: Date.now(),
                    ...this.dogAnimations[name]
                };
            };
            
            this.playDogAnimation('idle');
            this.dog.visible = false; // Hide until placed
            this.statusEl.textContent = 'Using fallback dog model. Find a surface to place it.';
        }
        
        updateDogAnimation() {
            // Update animation mixer if it exists
            if (this.mixer) {
                const delta = this.clock.getDelta();
                this.mixer.update(delta);
            }
        }
        
        playDogAnimation(name) {
            if (!this.dogAnimations || Object.keys(this.dogAnimations).length === 0) {
                return; // No animations available
            }
            
            // Stop any current animation
            if (this.currentAnimation) {
                this.currentAnimation.fadeOut(0.5);
            }
            
            // Get animation by name (case insensitive)
            let animation = this.dogAnimations[name];
            if (!animation) {
                // Try lowercase
                animation = this.dogAnimations[name.toLowerCase()];
            }
            
            // If still not found, use idle as fallback
            if (!animation && this.dogAnimations['idle']) {
                animation = this.dogAnimations['idle'];
            } else if (!animation && Object.values(this.dogAnimations).length > 0) {
                // Last resort: just use the first available animation
                animation = Object.values(this.dogAnimations)[0];
            }
            
            if (animation) {
                animation.reset().fadeIn(0.5).play();
                this.currentAnimation = animation;
            }
        }
        
        placeDog() {
            if (!this.reticle.visible) {
                this.statusEl.textContent = 'Can\'t place dog yet - find a surface';
                return;
            }
            
            if (!this.dogPlaced) {
                this.dog.position.setFromMatrixPosition(this.reticle.matrix);
                this.dog.visible = true;
                this.dogPlaced = true;
                
                this.placeDogButton.style.display = 'none';
                this.talkButton.style.display = 'block';
                this.petButton.style.display = 'block';
                this.throwBallButton.style.display = 'block';
                
                this.statusEl.textContent = 'Your dog is ready! Interact with it.';
                
                // Initial greeting from the dog
                setTimeout(() => {
                    this.simulateLLMResponse('A user has just placed you in their room. How do you react?');
                }, 1000);
            }
        }
        
        activateSpeechInput() {
            this.speechInput.style.display = 'block';
            this.speechInput.focus();
        }
        
        async talkToDog(text) {
            this.statusEl.textContent = `You: ${text}`;
            this.playDogAnimation('excited');
            
            await this.simulateLLMResponse(`The user says to you: "${text}". How do you respond as a dog?`);
        }
        
        async interactWithDog(action) {
            if (action === 'pet') {
                this.statusEl.textContent = 'You pet the dog';
                await this.simulateLLMResponse('The user is petting you. How do you react?');
            }
        }
        
        throwBall() {
            if (!this.ball) {
                // Create a ball
                this.ball = new THREE.Mesh(
                    new THREE.SphereGeometry(0.05, 16, 16),
                    new THREE.MeshStandardMaterial({ color: 0xff0000 })
                );
                this.scene.add(this.ball);
            }
            
            // Position the ball near the dog
            this.ball.position.copy(this.dog.position);
            this.ball.position.y += 0.5;
            this.ball.position.z += 0.5;
            this.ball.visible = true;
            
            // Simulate throwing animation
            const startPos = this.ball.position.clone();
            const endPos = this.dog.position.clone();
            endPos.x += (Math.random() - 0.5) * 2;
            endPos.z += (Math.random() - 0.5) * 2;
            
            const animateBall = () => {
                const progress = (Date.now() - throwStart) / 1000; // 1 second animation
                
                if (progress < 1) {
                    // Parabolic arc
                    const t = progress;
                    this.ball.position.x = startPos.x + (endPos.x - startPos.x) * t;
                    this.ball.position.z = startPos.z + (endPos.z - startPos.z) * t;
                    this.ball.position.y = startPos.y + 1 * Math.sin(Math.PI * t); // Arc height
                    
                    requestAnimationFrame(animateBall);
                } else {
                    this.ball.position.copy(endPos);
                    this.ball.position.y = 0.05; // On the ground
                    
                    // Make the dog react to the ball
                    this.simulateLLMResponse('The user threw a ball near you. How do you react?');
                }
            };
            
            const throwStart = Date.now();
            animateBall();
            
            this.statusEl.textContent = 'You threw a ball';
        }
        
        async simulateLLMResponse(prompt) {
            // Show thinking indicator
            this.thinkingEl.style.display = 'block';
            
            // Add to context
            this.llmContext.currentPrompt = prompt;
            this.llmContext.memory.push({ role: "user", content: prompt });
            
            let response = "";
            
            try {
                // Try to use the real API first
                response = await this.callLLMAPI(prompt);
            } catch (error) {
                console.error('Error using LLM API, falling back to simulation:', error);
                
                // Simulate API delay
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                // Simulate responses based on prompt keywords (fallback)
                if (prompt.includes("placed you in")) {
                    response = "wags tail excitedly, looks around curiously, then sits and tilts head";
                    this.playDogAnimation('excited');
                } else if (prompt.includes("petting you")) {
                    response = "closes eyes happily, leans into the pets, tail thumps against floor";
                    this.playDogAnimation('idle');
                } else if (prompt.includes("threw a ball")) {
                    response = "barks excitedly, runs to ball, picks it up and brings it back, tail wagging";
                    this.playDogAnimation('walking');
                } else if (prompt.includes("says to you")) {
                    // Pick a random response for speech
                    const responses = [
                        "tilts head curiously, ears perked up",
                        "wags tail and makes excited whining sound",
                        "barks once and jumps up slightly",
                        "sits attentively, looking at you with head tilted"
                    ];
                    response = responses[Math.floor(Math.random() * responses.length)];
                    this.playDogAnimation(Math.random() > 0.5 ? 'excited' : 'idle');
                } else {
                    response = "looks at you with head tilted";
                }
            }
            
            // Add to memory
            this.llmContext.memory.push({ role: "assistant", content: response });
            
            // Limit memory to last 10 interactions
            if (this.llmContext.memory.length > 10) {
                this.llmContext.memory = this.llmContext.memory.slice(-10);
            }
            
            this.statusEl.textContent = `Dog: ${response}`;
            this.thinkingEl.style.display = 'none';
            
            return response;
        }
        
        /**
         * Actual LLM API call function - replace the simulation function with this
         * when you're ready to connect to a real API
         */
        async callLLMAPI(prompt) {
            try {
                const response = await fetch('/api/llm', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        systemPrompt: this.llmContext.systemPrompt,
                        messages: this.llmContext.memory,
                        // Add any API specific parameters here
                        temperature: 0.7,
                        max_tokens: 50
                    })
                });
                
                const data = await response.json();
                
                // Structure depends on the API you're using
                return data.choices[0].message.content;
            } catch (error) {
                console.error('Error calling LLM API:', error);
                return "tilts head with confusion";
            }
        }
        
        setupEventListeners() {
            window.addEventListener('resize', () => {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }
        
        render(timestamp, frame) {
            if (frame) {
                const referenceSpace = this.renderer.xr.getReferenceSpace();
                const session = this.renderer.xr.getSession();
                
                if (this.hitTestSourceRequested === false) {
                    session.requestReferenceSpace('viewer').then((referenceSpace) => {
                        session.requestHitTestSource({ space: referenceSpace }).then((source) => {
                            this.hitTestSource = source;
                        });
                    });
                    
                    session.addEventListener('end', () => {
                        this.hitTestSourceRequested = false;
                        this.hitTestSource = null;
                    });
                    
                    this.hitTestSourceRequested = true;
                }
                
                if (this.hitTestSource) {
                    const hitTestResults = frame.getHitTestResults(this.hitTestSource);
                    
                    if (hitTestResults.length) {
                        const hit = hitTestResults[0];
                        
                        this.reticle.visible = true;
                        this.reticle.matrix.fromArray(hit.getPose(referenceSpace).transform.matrix);
                        
                        if (this.statusEl.textContent === 'Looking for surface...') {
                            this.statusEl.textContent = 'Surface found! Click "Place Dog"';
                        }
                    } else {
                        this.reticle.visible = false;
                    }
                }
            }
            
            // Update animations
            this.updateDogAnimation();
            
            this.renderer.render(this.scene, this.camera);
        }
    }
    
    // Initialize the app when the page loads
    window.addEventListener('DOMContentLoaded', () => {
        // Log initial diagnostic info
        logger.info(`User Agent: ${navigator.userAgent}`);
        logger.info(`Screen: ${window.innerWidth}x${window.innerHeight}, pixel ratio: ${window.devicePixelRatio}`);
        logger.checkXRCapabilities();
        
        const app = new ARDogApp();
    });
    
    // Fallback 3D Mode for devices without AR support
    function startFallback3DMode() {
        logger.info('Starting fallback 3D mode');
        
        // Create simple 3D scene
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        // Set background color
        scene.background = new THREE.Color(0xaaaaaa);
        
        // Add lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);
        
        // Create renderer
        const renderer = new THREE.WebGLRenderer({ 
            canvas: document.getElementById('canvas'),
            antialias: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        
        // Position camera
        camera.position.z = 3.0; // Increased from 1.5 to zoom out more
        camera.position.y = 1.0; // Increased from 0.5 to look from a higher angle
        camera.lookAt(0, 0, 0); // Look at the center
        
        // Add ground plane
        const ground = new THREE.Mesh(
            new THREE.PlaneGeometry(10, 10),
            new THREE.MeshStandardMaterial({ color: 0x88aa88 })
        );
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -0.3;
        scene.add(ground);
        
        // Add orbit controls via mouse drag
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        
        document.addEventListener('mousedown', (e) => { 
            isDragging = true; 
            previousMousePosition = { x: e.clientX, y: e.clientY };
        });
        
        document.addEventListener('mouseup', () => { isDragging = false; });
        
        document.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaMove = {
                    x: e.clientX - previousMousePosition.x,
                    y: e.clientY - previousMousePosition.y
                };
                
                // Rotate dog container based on mouse movement
                if (dogContainer) {
                    dogContainer.rotation.y += deltaMove.x * 0.01;
                }
                
                previousMousePosition = { x: e.clientX, y: e.clientY };
            }
        });
        
        // Add touch support
        document.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                isDragging = true;
                previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            }
        });
        
        document.addEventListener('touchend', () => { isDragging = false; });
        
        document.addEventListener('touchmove', (e) => {
            if (isDragging && e.touches.length === 1) {
                const deltaMove = {
                    x: e.touches[0].clientX - previousMousePosition.x,
                    y: e.touches[0].clientY - previousMousePosition.y
                };
                
                // Rotate dog container based on touch movement
                if (dogContainer) {
                    dogContainer.rotation.y += deltaMove.x * 0.01;
                }
                
                previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                e.preventDefault(); // Prevent scrolling
            }
        });
        
        // Create container for dog (so we can rotate it)
        const dogContainer = new THREE.Group();
        scene.add(dogContainer);
        
        // Load dog model
        const loader = new THREE.GLTFLoader();
        let mixer = null;
        
        // Status update
        const statusEl = document.getElementById('status');
        statusEl.textContent = 'Loading dog model...';
        
        // Show UI buttons
        document.getElementById('talk').style.display = 'block';
        document.getElementById('pet').style.display = 'block';
        document.getElementById('throw-ball').style.display = 'block';
        
        // Try to load the dog model
        loader.load(
            '/assets/corgy.glb',
            (gltf) => {
                const dog = gltf.scene;
                dog.scale.set(0.15, 0.15, 0.15);
                
                // Center the model
                const box = new THREE.Box3().setFromObject(dog);
                const center = box.getCenter(new THREE.Vector3());
                dog.position.x += (dog.position.x - center.x);
                dog.position.y += (dog.position.y - center.y) + 0.3;
                dog.position.z += (dog.position.z - center.z);
                
                // Add to container
                dogContainer.add(dog);
                
                // Setup animations
                if (gltf.animations && gltf.animations.length) {
                    mixer = new THREE.AnimationMixer(dog);
                    const action = mixer.clipAction(gltf.animations[0]);
                    action.play();
                }
                
                statusEl.textContent = '3D Mode Active - Drag to rotate view';
                logger.info('Dog model loaded in 3D mode');
            },
            (xhr) => {
                const percent = Math.floor(xhr.loaded / xhr.total * 100);
                statusEl.textContent = `Loading dog model: ${percent}%`;
            },
            (error) => {
                console.error('Error loading dog model:', error);
                statusEl.textContent = 'Error loading dog. Using fallback.';
                
                // Create a simple dog placeholder
                createPrimitiveDog(dogContainer);
            }
        );
        
        // Clock for animations
        const clock = new THREE.Clock();
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Update animations
            if (mixer) {
                mixer.update(clock.getDelta());
            }
            
            renderer.render(scene, camera);
        }
        
        // Start animation loop
        animate();
        
        // Connect interaction buttons
        document.getElementById('talk').addEventListener('click', () => {
            document.getElementById('speech-input').style.display = 'block';
            document.getElementById('speech-input').focus();
        });
        
        document.getElementById('speech-input').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                const text = document.getElementById('speech-input').value.trim();
                if (text) {
                    statusEl.textContent = `You: ${text}`;
                    document.getElementById('speech-input').value = '';
                    document.getElementById('speech-input').style.display = 'none';
                    
                    // Show dog thinking
                    document.getElementById('thinking').style.display = 'block';
                    
                    // Simulate response after delay
                    setTimeout(() => {
                        document.getElementById('thinking').style.display = 'none';
                        const responses = [
                            "wags tail excitedly",
                            "tilts head curiously",
                            "barks happily",
                            "looks at you with interest"
                        ];
                        statusEl.textContent = `Dog: ${responses[Math.floor(Math.random() * responses.length)]}`;
                    }, 1500);
                }
            }
        });
        
        document.getElementById('pet').addEventListener('click', () => {
            statusEl.textContent = "You pet the dog";
            
            // Show dog thinking
            document.getElementById('thinking').style.display = 'block';
            
            // Simulate response after delay
            setTimeout(() => {
                document.getElementById('thinking').style.display = 'none';
                statusEl.textContent = "Dog: wags tail happily and leans into the pets";
            }, 1000);
        });
        
        document.getElementById('throw-ball').addEventListener('click', () => {
            statusEl.textContent = "You threw a ball";
            
            // Create a ball if it doesn't exist
            let ball = scene.getObjectByName("ball");
            if (!ball) {
                ball = new THREE.Mesh(
                    new THREE.SphereGeometry(0.05, 16, 16),
                    new THREE.MeshStandardMaterial({ color: 0xff0000 })
                );
                ball.name = "ball";
                scene.add(ball);
            }
            
            // Position the ball
            ball.position.set(0, 0.3, 0);
            ball.visible = true;
            
            // Animate the ball throw
            const startPos = ball.position.clone();
            const endPos = new THREE.Vector3(
                (Math.random() - 0.5) * 2,
                0.05,
                (Math.random() - 0.5) * 2
            );
            
            const startTime = Date.now();
            
            function animateBall() {
                const progress = (Date.now() - startTime) / 1000; // 1 second animation
                
                if (progress < 1) {
                    // Parabolic arc
                    const t = progress;
                    ball.position.x = startPos.x + (endPos.x - startPos.x) * t;
                    ball.position.z = startPos.z + (endPos.z - startPos.z) * t;
                    ball.position.y = startPos.y + 0.5 * Math.sin(Math.PI * t); // Arc height
                    
                    requestAnimationFrame(animateBall);
                } else {
                    ball.position.copy(endPos);
                    
                    // Show dog thinking
                    document.getElementById('thinking').style.display = 'block';
                    
                    // Dog responds after the ball lands
                    setTimeout(() => {
                        document.getElementById('thinking').style.display = 'none';
                        statusEl.textContent = "Dog: barks excitedly and chases after the ball";
                    }, 1000);
                }
            }
            
            animateBall();
        });
    }
    
    // Function to create primitive dog for fallback
    function createPrimitiveDog(container) {
        // Body
        const body = new THREE.Mesh(
            new THREE.CapsuleGeometry(0.06, 0.12, 4, 8),
            new THREE.MeshStandardMaterial({ color: 0xA0522D })
        );
        body.rotation.z = Math.PI / 2;
        body.position.y = 0.12;
        container.add(body);
        
        // Head
        const head = new THREE.Mesh(
            new THREE.SphereGeometry(0.045, 16, 16),
            new THREE.MeshStandardMaterial({ color: 0x8B4513 })
        );
        head.position.set(0.09, 0.16, 0);
        container.add(head);
        
        // Eyes
        const eyeGeometry = new THREE.SphereGeometry(0.01, 8, 8);
        const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
        
        const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
        leftEye.position.set(0.12, 0.18, 0.025);
        container.add(leftEye);
        
        const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
        rightEye.position.set(0.12, 0.18, -0.025);
        container.add(rightEye);
        
        // Nose
        const nose = new THREE.Mesh(
            new THREE.SphereGeometry(0.012, 8, 8),
            new THREE.MeshBasicMaterial({ color: 0x000000 })
        );
        nose.position.set(0.14, 0.15, 0);
        container.add(nose);
        
        // Legs
        const legGeometry = new THREE.CylinderGeometry(0.012, 0.012, 0.06, 8);
        const legMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
        
        const legPositions = [
            [-0.04, 0.1, 0.04],
            [-0.04, 0.1, -0.04],
            [0.04, 0.1, 0.04],
            [0.04, 0.1, -0.04]
        ];
        
        legPositions.forEach(pos => {
            const leg = new THREE.Mesh(legGeometry, legMaterial);
            leg.position.set(...pos);
            container.add(leg);
        });
        
        // Tail
        const tail = new THREE.Mesh(
            new THREE.CylinderGeometry(0.01, 0.003, 0.06, 8),
            new THREE.MeshStandardMaterial({ color: 0x8B4513 })
        );
        tail.position.set(-0.1, 0.12, 0);
        tail.rotation.z = Math.PI / 4;
        container.add(tail);
        
        // Move entire container up to clear the ground
        container.position.y = 0.05;
        
        // Simple animation with smaller amplitude for the smaller dog
        const animateDog = () => {
            const time = Date.now() * 0.001;
            body.position.y = 0.12 + Math.sin(time * 2) * 0.006;
            head.position.y = 0.16 + Math.sin(time * 2) * 0.006;
            tail.rotation.z = Math.PI / 4 + Math.sin(time * 3) * 0.2;
            
            requestAnimationFrame(animateDog);
        };
        
        animateDog();
        
        logger.info('Primitive dog created for fallback');
        document.getElementById('status').textContent = '3D Mode Active - Drag to rotate view';
    }
    </script>
</body>
</html>
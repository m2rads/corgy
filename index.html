<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>AR AI Dog</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        #ui {
            position: absolute;
            bottom: 20px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: center;
            pointer-events: none;
        }
        .button {
            background: rgba(255, 255, 255, 0.7);
            border: none;
            border-radius: 30px;
            padding: 12px 20px;
            margin: 0 10px;
            font-weight: bold;
            pointer-events: auto;
        }
        /* New styles for fallback mode */
        #fallback-mode {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            display: none;
        }
        #fallback-button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            margin-top: 15px;
            cursor: pointer;
            font-weight: bold;
        }
        /* End new styles */
        #status {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 10px;
            border-radius: 5px;
            max-width: 80%;
        }
        #speech-input {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            padding: 12px;
            border-radius: 30px;
            border: none;
            background: rgba(255, 255, 255, 0.9);
            display: none;
            pointer-events: auto;
        }
        .thinking {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px 20px;
            border-radius: 10px;
            display: none;
        }
        /* Debug panel styles */
        #debug-panel {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.8);
            color: lime;
            font-family: monospace;
            font-size: 10px;
            max-height: 30%;
            overflow-y: auto;
            padding: 10px;
            display: none;
        }
        #debug-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="status">Looking for surface...</div>
    <div id="thinking" class="thinking">Dog is thinking...</div>
    <input type="text" id="speech-input" placeholder="Say something to the dog...">
    <div id="ui">
        <button id="start-ar" class="button">Start AR</button>
        <button id="place-dog" class="button" style="display: none;">Place Dog</button>
        <button id="talk" class="button" style="display: none;">Talk</button>
        <button id="pet" class="button" style="display: none;">Pet</button>
        <button id="throw-ball" class="button" style="display: none;">Throw Ball</button>
        <button id="walk" class="button" style="display: none;">Walk</button>
    </div>
    
    <!-- Debug Tools -->
    <button id="debug-toggle">Show Debug</button>
    <div id="debug-panel"></div>

    <!-- Fallback Mode UI -->
    <div id="fallback-mode">
        <h3>AR Not Supported</h3>
        <p>Your device or browser doesn't support WebXR for AR.</p>
        <p>You can still view the dog in 3D mode instead.</p>
        <button id="fallback-button">View in 3D Mode</button>
    </div>

    <!-- Import libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r132/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/DRACOLoader.js"></script>
    <!-- Add WebXR polyfills for better iOS support -->
    <script src="https://unpkg.com/webxr-polyfill@latest/build/webxr-polyfill.js"></script>

    <script>
    // Initialize WebXR polyfill first
    const polyfill = new WebXRPolyfill({
        // Specific options for iOS
        allowCardboardOnDesktop: true,
        enableLegacyWebVR: true
    });
    
    // Debug logger
    const logger = {
        logs: [],
        maxLogs: 100,
        
        log: function(message, type = 'info') {
            const timestamp = new Date().toISOString().substring(11, 23);
            const entry = `${timestamp} [${type.toUpperCase()}] ${message}`;
            this.logs.unshift(entry);
            
            // Trim log if needed
            if (this.logs.length > this.maxLogs) {
                this.logs.pop();
            }
            
            // Update debug panel if visible
            this.updatePanel();
            
            // Also log to console
            console.log(entry);
            
            // Send to server for logging important events
            if (type === 'error' || type === 'warn') {
                this.sendToServer(entry, type);
            }
        },
        
        info: function(message) {
            this.log(message, 'info');
        },
        
        warn: function(message) {
            this.log(message, 'warn');
        },
        
        error: function(message, error) {
            let errorDetails = message;
            if (error) {
                errorDetails += `: ${error.message || error}`;
                console.error(error);
            }
            this.log(errorDetails, 'error');
        },
        
        updatePanel: function() {
            const panel = document.getElementById('debug-panel');
            if (panel) {
                panel.innerHTML = this.logs.join('<br>');
            }
        },
        
        sendToServer: function(message, type) {
            try {
                fetch('/api/log', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        message,
                        type,
                        userAgent: navigator.userAgent,
                        timestamp: new Date().toISOString()
                    })
                }).catch(e => {
                    console.error('Failed to send log to server', e);
                    // Don't worry about server logging failing
                });
            } catch (e) {
                console.error('Error sending log to server', e);
                // Continue even if server logging fails
            }
        },
        
        checkXRCapabilities: function() {
            this.info('Checking XR capabilities...');
            
            // Try to check AR capabilities on server but don't rely on response
            fetch('/api/check-ar')
                .then(res => res.json())
                .then(data => {
                    this.info(`AR check endpoint response: ${JSON.stringify(data.message)}`);
                })
                .catch(err => {
                    this.info('AR check endpoint failed - continuing in offline mode');
                });
                
            // Check navigator.xr
            if (!navigator.xr) {
                this.error('WebXR API not available on this browser');
                return false;
            } else {
                this.info('WebXR API is available');
            }
            
            // Return results of basic check
            return !!navigator.xr;
        }
    };
    
    // Initialize debug panel
    document.getElementById('debug-toggle').addEventListener('click', function() {
        const panel = document.getElementById('debug-panel');
        if (panel.style.display === 'none' || !panel.style.display) {
            panel.style.display = 'block';
            this.textContent = 'Hide Debug';
        } else {
            panel.style.display = 'none';
            this.textContent = 'Show Debug';
        }
    });

    // Add fallback mode functionality
    document.getElementById('fallback-button').addEventListener('click', function() {
        document.getElementById('fallback-mode').style.display = 'none';
        startFallback3DMode();
    });

    // Main Application
    class ARDogApp {
        constructor() {
            // Scene setup
            this.canvas = document.getElementById('canvas');
            this.scene = new THREE.Scene();
            this.camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);
            
            // Renderer with iOS-friendly settings
            this.renderer = new THREE.WebGLRenderer({ 
                canvas: this.canvas, 
                antialias: true, 
                alpha: true,
                powerPreference: "high-performance",
                precision: "highp"
            });
            this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limit pixel ratio for performance
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.renderer.xr.enabled = true;
            
            // Extra debugging for iOS
            logger.info(`Using WebGL Renderer: ${this.renderer.getContext().getParameter(this.renderer.getContext().VERSION)}`);
            logger.info(`Renderer pixel ratio: ${this.renderer.getPixelRatio()}`);
            
            // AR elements
            this.hitTestSource = null;
            this.hitTestSourceRequested = false;
            this.reticle = new THREE.Mesh(
                new THREE.RingGeometry(0.15, 0.2, 32).rotateX(-Math.PI / 2),
                new THREE.MeshBasicMaterial()
            );
            this.reticle.matrixAutoUpdate = false;
            this.reticle.visible = false;
            this.scene.add(this.reticle);
            
            // Dog model and variables
            this.dog = null;
            this.dogPlaced = false;
            this.dogAnimations = {};
            this.currentAnimation = null;
            this.mixer = null;
            this.clock = new THREE.Clock();
            this.dogState = {
                mood: "neutral", // neutral, happy, sad, excited, tired
                lastInteractions: [],
                energy: 100,
                memory: {}
            };
            
            // LLM context
            this.llmContext = {
                currentPrompt: "",
                systemPrompt: `You are an AI dog in an augmented reality experience. You behave just like a real friendly dog would. 
                Your responses should be short actions the dog would take, using only a few words.
                Never speak in full sentences, just give the dog's actions and maybe a sound (like "woof!" or "whines").
                For example: "wags tail excitedly", "tilts head curiously", "jumps up and down, barking", "lies down and looks sad".
                You should never talk like a human - remember you are a dog!
                
                The following actions can be animated: walking, running, sitting, jumping, barking, wagging tail, tilting head.
                When responding, try to include these specific actions when appropriate for a more animated experience.
                For example, if the user asks the dog to sit, respond with "sits obediently, tail wagging" rather than just "obeys".
                If the user throws a ball, include "runs after the ball, picks it up, brings it back" with these specific actions.`,
                memory: []
            };
            
            // Physics objects
            this.ball = null;
            
            // UI elements
            this.statusEl = document.getElementById('status');
            this.startARButton = document.getElementById('start-ar');
            this.placeDogButton = document.getElementById('place-dog');
            this.talkButton = document.getElementById('talk');
            this.petButton = document.getElementById('pet');
            this.throwBallButton = document.getElementById('throw-ball');
            this.walkButton = document.getElementById('walk');
            this.speechInput = document.getElementById('speech-input');
            this.thinkingEl = document.getElementById('thinking');
            
            // Initialize
            this.setupLighting();
            this.setupEventListeners();
            this.initARButton();
        }
        
        setupLighting() {
            const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
            light.position.set(0.5, 1, 0.25);
            this.scene.add(light);
        }
        
        initARButton() {
            this.startARButton.addEventListener('click', () => {
                logger.info('Start AR button clicked');
                // Add a user gesture handler for iOS - Safari requires user gesture
                this.startARSession();
            });
        }
        
        startARSession() {
            logger.info('Starting AR session with WebXR version: ' + (navigator.xr ? 'Available' : 'Not available'));
            
            // Make sure this is being called from a user gesture for iOS Safari
            if (!navigator.xr) {
                logger.error('WebXR API not available in this browser');
                
                const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
                if (isIOS) {
                    logger.info('iOS device detected, attempting WebXR polyfill');
                    // Force showing the AR button on iOS even if navigator.xr is not detected
                    // The WebXR polyfill might make it work
                    this.statusEl.innerHTML = 'Using WebXR polyfill. If this does not work, your device may not support AR.';
                    
                    // Try to initialize AR anyway - the polyfill might handle it
                    this.tryInitializeAR();
                } else {
                    this.statusEl.innerHTML = 'AR not supported on this device/browser.';
                    // Show fallback mode
                    document.getElementById('fallback-mode').style.display = 'block';
                }
                return;
            }
            
            this.tryInitializeAR();
        }
        
        tryInitializeAR() {
            logger.info('Trying to initialize AR');
            
            if (typeof navigator.xr.isSessionSupported !== 'function') {
                logger.error('isSessionSupported is not a function - polyfill may not be working correctly');
                this.statusEl.innerHTML = 'WebXR API not fully supported on this browser.';
                // Show fallback mode
                document.getElementById('fallback-mode').style.display = 'block';
                return;
            }
            
            navigator.xr.isSessionSupported('immersive-ar')
                .then((supported) => {
                    if (supported) {
                        logger.info('immersive-ar is supported, requesting session');
                        
                        // Use minimal required features for iOS compatibility
                        const sessionInit = { 
                            requiredFeatures: ['hit-test'],
                            optionalFeatures: ['dom-overlay'],
                        };
                        
                        // Add dom-overlay only if supported
                        if (sessionInit.optionalFeatures.includes('dom-overlay')) {
                            sessionInit.domOverlay = { root: document.body };
                        }
                        
                        navigator.xr.requestSession('immersive-ar', sessionInit)
                            .then(session => {
                                logger.info('AR session created successfully');
                                this.onSessionStarted(session);
                            })
                            .catch(error => {
                                logger.error('Failed to start AR session', error);
                                
                                if (error.message.includes('permission')) {
                                    this.statusEl.textContent = 'Camera permission denied. Please allow camera access.';
                                } else {
                                    this.statusEl.textContent = `AR session failed: ${error.message || error}`;
                                }
                                // Show fallback mode
                                document.getElementById('fallback-mode').style.display = 'block';
                            });
                    } else {
                        logger.error('immersive-ar not supported on this device');
                        this.statusEl.innerHTML = 'AR not supported on this device. Your device might not have AR capabilities.';
                        // Show fallback mode
                        document.getElementById('fallback-mode').style.display = 'block';
                    }
                })
                .catch(error => {
                    logger.error('Error checking AR support', error);
                    this.statusEl.textContent = `Error checking AR support: ${error.message || error}`;
                    // Show fallback mode
                    document.getElementById('fallback-mode').style.display = 'block';
                });
        }
        
        onSessionStarted(session) {
            logger.info('AR session started, configuring');
            this.startARButton.style.display = 'none';
            this.placeDogButton.style.display = 'block';
            
            this.renderer.xr.setReferenceSpaceType('local');
            this.renderer.xr.setSession(session);
            
            session.addEventListener('end', this.onSessionEnded.bind(this));
            
            this.placeDogButton.addEventListener('click', this.placeDog.bind(this));
            this.talkButton.addEventListener('click', this.activateSpeechInput.bind(this));
            this.petButton.addEventListener('click', () => this.interactWithDog('pet'));
            this.throwBallButton.addEventListener('click', () => this.throwBall());
            this.walkButton.addEventListener('click', () => this.walkDog());
            
            this.speechInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    const text = this.speechInput.value.trim();
                    if (text) {
                        this.talkToDog(text);
                        this.speechInput.value = '';
                        this.speechInput.style.display = 'none';
                    }
                }
            });
            
            this.loadDogModel();
            
            this.renderer.setAnimationLoop(this.render.bind(this));
        }
        
        onSessionEnded() {
            this.startARButton.style.display = 'block';
            this.placeDogButton.style.display = 'none';
            this.talkButton.style.display = 'none';
            this.petButton.style.display = 'none';
            this.throwBallButton.style.display = 'none';
            this.walkButton.style.display = 'none';
            this.renderer.setAnimationLoop(null);
        }
        
        async loadDogModel() {
            this.statusEl.textContent = 'Loading dog model...';
            
            // Load the corgy.glb model using GLTFLoader
            const loader = new THREE.GLTFLoader();
            
            try {
                const gltf = await new Promise((resolve, reject) => {
                    loader.load(
                        '/assets/corgy.glb',  // Path to the model
                        resolve,
                        (xhr) => {
                            console.log((xhr.loaded / xhr.total * 100) + '% loaded');
                        },
                        reject
                    );
                });
                
                this.dog = gltf.scene;
                
                // Scale if needed (adjust based on your model size)
                this.dog.scale.set(0.15, 0.15, 0.15);
                
                // Center the model if needed
                const box = new THREE.Box3().setFromObject(this.dog);
                const center = box.getCenter(new THREE.Vector3());
                this.dog.position.x += (this.dog.position.x - center.x);
                this.dog.position.y += (this.dog.position.y - center.y) + 0.3;
                this.dog.position.z += (this.dog.position.z - center.z);
                
                // Setup animations if your model has them
                if (gltf.animations && gltf.animations.length) {
                    this.mixer = new THREE.AnimationMixer(this.dog);
                    
                    // Store animations
                    gltf.animations.forEach(clip => {
                        const action = this.mixer.clipAction(clip);
                        this.dogAnimations[clip.name] = action;
                    });
                    
                    // Define animation mappings
                    if (!this.dogAnimations['idle'] && gltf.animations.length > 0) {
                        // If no specific 'idle' animation, use the first one as default
                        this.dogAnimations['idle'] = this.mixer.clipAction(gltf.animations[0]);
                    }
                    
                    // Check for other common animations and create mappings
                    const animationNames = gltf.animations.map(a => a.name.toLowerCase());
                    
                    if (!this.dogAnimations['walking']) {
                        // Try to find walking animation
                        const walkIndex = animationNames.findIndex(n => 
                            n.includes('walk') || n.includes('run') || n.includes('trot'));
                        if (walkIndex >= 0) {
                            this.dogAnimations['walking'] = this.mixer.clipAction(gltf.animations[walkIndex]);
                        } else {
                            // Fallback to idle
                            this.dogAnimations['walking'] = this.dogAnimations['idle'];
                        }
                    }
                    
                    if (!this.dogAnimations['excited']) {
                        // Try to find excited animation
                        const excitedIndex = animationNames.findIndex(n => 
                            n.includes('jump') || n.includes('bark') || n.includes('excited'));
                        if (excitedIndex >= 0) {
                            this.dogAnimations['excited'] = this.mixer.clipAction(gltf.animations[excitedIndex]);
                        } else {
                            // Fallback to idle
                            this.dogAnimations['excited'] = this.dogAnimations['idle'];
                        }
                    }
                    
                    // Play default animation
                    this.playDogAnimation('idle');
                }
                
                this.dog.visible = false;  // Hide until placed
                this.scene.add(this.dog);
                
                this.statusEl.textContent = 'Dog model loaded! Find a surface to place it.';
                
            } catch (error) {
                console.error('Error loading dog model:', error);
                this.statusEl.textContent = 'Error loading dog model. Using fallback.';
                
                // Fallback to primitive dog if model loading fails
                this.createPrimitiveDog();
            }
        }
        
        createPrimitiveDog() {
            // Create a simple dog placeholder using primitives
            const dogGroup = new THREE.Group();
            
            // Body
            const body = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.06, 0.12, 4, 8),
                new THREE.MeshStandardMaterial({ color: 0xA0522D })
            );
            body.rotation.z = Math.PI / 2;
            body.position.y = 0.12;
            dogGroup.add(body);
            
            // Head
            const head = new THREE.Mesh(
                new THREE.SphereGeometry(0.045, 16, 16),
                new THREE.MeshStandardMaterial({ color: 0x8B4513 })
            );
            head.position.set(0.09, 0.16, 0);
            dogGroup.add(head);
            
            // Eyes
            const eyeGeometry = new THREE.SphereGeometry(0.01, 8, 8);
            const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(0.12, 0.18, 0.025);
            dogGroup.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.12, 0.18, -0.025);
            dogGroup.add(rightEye);
            
            // Nose
            const nose = new THREE.Mesh(
                new THREE.SphereGeometry(0.012, 8, 8),
                new THREE.MeshBasicMaterial({ color: 0x000000 })
            );
            nose.position.set(0.14, 0.15, 0);
            dogGroup.add(nose);
            
            // Legs
            const legGeometry = new THREE.CylinderGeometry(0.012, 0.012, 0.06, 8);
            const legMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            
            const legs = [];
            const legPositions = [
                [-0.04, 0.1, 0.04],
                [-0.04, 0.1, -0.04],
                [0.04, 0.1, 0.04],
                [0.04, 0.1, -0.04]
            ];
            
            legPositions.forEach(pos => {
                const leg = new THREE.Mesh(legGeometry, legMaterial);
                leg.position.set(...pos);
                dogGroup.add(leg);
                legs.push(leg);
            });
            
            // Tail
            const tail = new THREE.Mesh(
                new THREE.CylinderGeometry(0.01, 0.003, 0.06, 8),
                new THREE.MeshStandardMaterial({ color: 0x8B4513 })
            );
            tail.position.set(-0.1, 0.12, 0);
            tail.rotation.z = Math.PI / 4;
            dogGroup.add(tail);
            
            // Add to scene
            this.dog = dogGroup;
            this.scene.add(this.dog);
            
            // Define primitive animations with more variety
            this.dogAnimations = {
                idle: { duration: 2000, onUpdate: (t) => {
                    const y = 0.05 * Math.sin(t * Math.PI);
                    body.position.y = 0.12 + y * 0.02;
                    head.position.y = 0.16 + y * 0.02;
                }},
                walking: { duration: 1000, onUpdate: (t) => {
                    const cycle = t * Math.PI * 2;
                    legs.forEach((leg, i) => {
                        leg.position.y = 0.06 + Math.abs(Math.sin(cycle + i * Math.PI/2)) * 0.005;
                    });
                    body.position.y = 0.12 + Math.sin(cycle * 2) * 0.002;
                    // Add slight head bob while walking
                    head.position.y = 0.16 + Math.sin(cycle * 2) * 0.005;
                }},
                excited: { duration: 800, onUpdate: (t) => {
                    const cycle = t * Math.PI * 4;
                    body.position.y = 0.12 + Math.abs(Math.sin(cycle)) * 0.01;
                    head.position.y = 0.16 + Math.abs(Math.sin(cycle)) * 0.01;
                    tail.rotation.z = Math.PI / 4 + Math.sin(cycle * 2) * 0.05;
                    // Add slight body rotation for more excitement
                    body.rotation.x = Math.sin(cycle) * 0.05;
                }},
                sleeping: { duration: 3000, onUpdate: (t) => {
                    const breathing = Math.sin(t * Math.PI) * 0.002;
                    body.scale.y = 1 + breathing;
                    // Lower head position for sleeping pose
                    head.position.y = 0.14 + breathing * 0.5;
                }},
                // New animations
                run: { duration: 600, onUpdate: (t) => {
                    const cycle = t * Math.PI * 3; // Faster cycle for running
                    legs.forEach((leg, i) => {
                        leg.position.y = 0.06 + Math.abs(Math.sin(cycle + i * Math.PI/2)) * 0.01;
                    });
                    body.position.y = 0.12 + Math.sin(cycle * 2) * 0.005;
                    head.position.y = 0.16 + Math.sin(cycle * 2) * 0.008;
                    tail.rotation.z = Math.PI / 4 + Math.sin(cycle) * 0.1;
                }},
                fetch: { duration: 1500, onUpdate: (t) => {
                    if (t < 0.5) {
                        // Running to fetch
                        const cycle = t * Math.PI * 6;
                        legs.forEach((leg, i) => {
                            leg.position.y = 0.06 + Math.abs(Math.sin(cycle + i * Math.PI/2)) * 0.01;
                        });
                        body.position.y = 0.12 + Math.sin(cycle * 2) * 0.005;
                    } else {
                        // Coming back
                        const cycle = (t - 0.5) * Math.PI * 4;
                        body.position.y = 0.12 + Math.abs(Math.sin(cycle)) * 0.01;
                        head.position.y = 0.16 + Math.abs(Math.sin(cycle)) * 0.01;
                        tail.rotation.z = Math.PI / 4 + Math.sin(cycle * 2) * 0.1;
                    }
                }}
            };
            
            // Override the updateDogAnimation method for primitive animations
            this.updateDogAnimationOriginal = this.updateDogAnimation;
            this.updateDogAnimation = () => {
                if (!this.currentAnimation || !this.dog) {
                    // Animation or dog not ready yet
                    return; 
                }
                
                // Debug info - log once per second to avoid console spam
                const now = Date.now();
                if (!this._lastAnimDebug || now - this._lastAnimDebug > 1000) {
                    console.log(`Updating animation: ${this.currentAnimation.name}`);
                    this._lastAnimDebug = now;
                }
                
                const elapsed = Date.now() - this.currentAnimation.startTime;
                const t = (elapsed % this.currentAnimation.duration) / this.currentAnimation.duration;
                
                try {
                    this.currentAnimation.onUpdate(t);
                } catch (error) {
                    console.error('Error in animation update:', error);
                }
            };
            
            // Override the playDogAnimation method for primitive animations
            this.playDogAnimationOriginal = this.playDogAnimation;
            this.playDogAnimation = (name) => {
                this.currentAnimation = {
                    name,
                    startTime: Date.now(),
                    ...this.dogAnimations[name]
                };
            };
            
            this.playDogAnimation('idle');
            this.dog.visible = false; // Hide until placed
            this.statusEl.textContent = 'Using fallback dog model. Find a surface to place it.';
        }
        
        updateDogAnimation() {
            // Special handling for procedural animations
            if (this.currentAnimation && this.currentAnimation.isProceduralAnimation) {
                const elapsed = Date.now() - this.currentAnimation.startTime;
                const duration = this.currentAnimation.duration;
                const t = (elapsed % duration) / duration;
                
                if (this.currentAnimation.onUpdate) {
                    this.currentAnimation.onUpdate(t);
                }
                return;
            }
            
            // Original animation mixer handling
            if (this.mixer) {
                const delta = this.clock.getDelta();
                this.mixer.update(delta);
            }
        }
        
        playDogAnimation(name) {
            if (!this.dogAnimations || Object.keys(this.dogAnimations).length === 0) {
                return; // No animations available
            }
            
            // First, check if we should use a procedural animation
            if (this.proceduralAnimations && this.proceduralAnimations[name]) {
                // Stop any current animation
                if (this.currentAnimation && typeof this.currentAnimation.fadeOut === 'function') {
                    this.currentAnimation.fadeOut(0.5);
                }
                
                // Reset bones to original positions
                this.resetBonesToOriginalPositions();
                
                // Create a procedural animation
                this.currentAnimation = {
                    name,
                    isProceduralAnimation: true,
                    startTime: Date.now(),
                    ...this.proceduralAnimations[name]
                };
                
                return;
            }
            
            // If not procedural, use the original animation system
            // Stop any current animation
            if (this.currentAnimation) {
                if (typeof this.currentAnimation.fadeOut === 'function') {
                    this.currentAnimation.fadeOut(0.5);
                }
            }
            
            // Get animation by name (case insensitive)
            let animation = this.dogAnimations[name];
            if (!animation) {
                // Try lowercase
                animation = this.dogAnimations[name.toLowerCase()];
            }
            
            // If still not found, use idle as fallback
            if (!animation && this.dogAnimations['idle']) {
                animation = this.dogAnimations['idle'];
            } else if (!animation && Object.values(this.dogAnimations).length > 0) {
                // Last resort: just use the first available animation
                animation = Object.values(this.dogAnimations)[0];
            }
            
            if (animation) {
                if (typeof animation.reset === 'function') {
                    animation.reset().fadeIn(0.5).play();
                }
                this.currentAnimation = animation;
            }
        }
        
        walkDog() {
            console.log('Walking the dog (direct animation)');
            
            // Start the walking animation
            const dogApp = window.dogApp || window.fallbackDogApp;
            if (dogApp) {
                dogApp.statusEl.textContent = 'Walking...';
                
                // Debug available animations
                if (dogApp.dogAnimations) {
                    console.log('Available animations:', Object.keys(dogApp.dogAnimations));
                } else {
                    console.log('No dogAnimations object found');
                }
                
                // Try walking with extra logging
                console.log('Attempting to play walking animation');
                try {
                    dogApp.playDogAnimation('walking');
                    console.log('Walking animation started');
                    
                    // Add a manual walking motion as backup
                    fakeWalk(dogApp.dog);
                } catch (error) {
                    console.error('Error playing walking animation:', error);
                    // Still try the fallback
                    fakeWalk(dogApp.dog);
                }
                
                // After 5 seconds, return to idle
                setTimeout(() => {
                    try {
                        dogApp.playDogAnimation('idle');
                        console.log('Returned to idle animation');
                    } catch (error) {
                        console.error('Error returning to idle:', error);
                    }
                    dogApp.statusEl.textContent = 'Dog placed! Interact with it using the buttons.';
                    console.log('Dog walk completed');
                }, 5000);
            } else {
                console.error('Dog app not available');
            }
        }
        
        setupEventListeners() {
            window.addEventListener('resize', () => {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }
        
        render(timestamp, frame) {
            if (frame) {
                const referenceSpace = this.renderer.xr.getReferenceSpace();
                const session = this.renderer.xr.getSession();
                
                if (this.hitTestSourceRequested === false) {
                    session.requestReferenceSpace('viewer').then((referenceSpace) => {
                        session.requestHitTestSource({ space: referenceSpace }).then((source) => {
                            this.hitTestSource = source;
                        });
                    });
                    
                    session.addEventListener('end', () => {
                        this.hitTestSourceRequested = false;
                        this.hitTestSource = null;
                    });
                    
                    this.hitTestSourceRequested = true;
                }
                
                if (this.hitTestSource) {
                    const hitTestResults = frame.getHitTestResults(this.hitTestSource);
                    
                    if (hitTestResults.length) {
                        const hit = hitTestResults[0];
                        
                        this.reticle.visible = true;
                        this.reticle.matrix.fromArray(hit.getPose(referenceSpace).transform.matrix);
                        
                        if (this.statusEl.textContent === 'Looking for surface...') {
                            this.statusEl.textContent = 'Surface found! Click "Place Dog"';
                        }
                    } else {
                        this.reticle.visible = false;
                    }
                }
            }
            
            // Update animations
            this.updateDogAnimation();
            
            this.renderer.render(this.scene, this.camera);
        }
    }
    
    // Initialize the app when the page loads
    window.addEventListener('DOMContentLoaded', () => {
        // Log initial diagnostic info
        logger.info(`User Agent: ${navigator.userAgent}`);
        logger.info(`Screen: ${window.innerWidth}x${window.innerHeight}, pixel ratio: ${window.devicePixelRatio}`);
        logger.checkXRCapabilities();
        
        const app = new ARDogApp();
        
        // Make sure crucial functions are available globally
        window.dogApp = app;
        
        // Make sure we've exposed these functions globally
        window.walkDog = walkDog;
        window.fakeWalk = fakeWalk;
        
        logger.info("Global functions initialized on window object");
    });
    
    // Fallback 3D Mode for devices without AR support
    function startFallback3DMode() {
        logger.info('Starting fallback 3D mode');
        
        // Create simple 3D scene
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        // Set background color
        scene.background = new THREE.Color(0xaaaaaa);
        
        // Add lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);
        
        // Create renderer
        const renderer = new THREE.WebGLRenderer({ 
            canvas: document.getElementById('canvas'),
            antialias: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        
        // Position camera
        camera.position.z = 3.0; // Increased from 1.5 to zoom out more
        camera.position.y = 1.0; // Increased from 0.5 to look from a higher angle
        camera.lookAt(0, 0, 0); // Look at the center
        
        // Add ground plane
        const ground = new THREE.Mesh(
            new THREE.PlaneGeometry(10, 10),
            new THREE.MeshStandardMaterial({ color: 0x88aa88 })
        );
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -0.3;
        scene.add(ground);
        
        // Add orbit controls via mouse drag
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        
        document.addEventListener('mousedown', (e) => { 
            isDragging = true; 
            previousMousePosition = { x: e.clientX, y: e.clientY };
        });
        
        document.addEventListener('mouseup', () => { isDragging = false; });
        
        document.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaMove = {
                    x: e.clientX - previousMousePosition.x,
                    y: e.clientY - previousMousePosition.y
                };
                
                // Rotate dog container based on mouse movement
                if (dogContainer) {
                    dogContainer.rotation.y += deltaMove.x * 0.01;
                }
                
                previousMousePosition = { x: e.clientX, y: e.clientY };
            }
        });
        
        // Add touch support
        document.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                isDragging = true;
                previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            }
        });
        
        document.addEventListener('touchend', () => { isDragging = false; });
        
        document.addEventListener('touchmove', (e) => {
            if (isDragging && e.touches.length === 1) {
                const deltaMove = {
                    x: e.touches[0].clientX - previousMousePosition.x,
                    y: e.touches[0].clientY - previousMousePosition.y
                };
                
                // Rotate dog container based on touch movement
                if (dogContainer) {
                    dogContainer.rotation.y += deltaMove.x * 0.01;
                }
                
                previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                e.preventDefault(); // Prevent scrolling
            }
        });
        
        // Create container for dog (so we can rotate it)
        const dogContainer = new THREE.Group();
        scene.add(dogContainer);
        
        // Create a fallback dog app object with necessary methods
        // This is what was missing - we need to create a global dogApp
        window.fallbackDogApp = {
            dog: null,
            dogAnimations: {},
            statusEl: document.getElementById('status'),
            playDogAnimation: function(name) {
                console.log(`Fallback app trying to play animation: ${name}`);
                // Animation handling will happen in the fakeWalk function
            }
        };
        
        // Make this available globally for the walkdog function
        window.dogApp = window.fallbackDogApp;
        
        // Load dog model
        const loader = new THREE.GLTFLoader();
        let mixer = null;
        
        // Status update
        const statusEl = document.getElementById('status');
        statusEl.textContent = 'Loading dog model...';
        
        // Show UI buttons
        document.getElementById('talk').style.display = 'block';
        document.getElementById('pet').style.display = 'block';
        document.getElementById('throw-ball').style.display = 'block';
        document.getElementById('walk').style.display = 'block';
        
        // Try to load the dog model
        loader.load(
            '/assets/corgy.glb',
            (gltf) => {
                const dog = gltf.scene;
                dog.scale.set(0.15, 0.15, 0.15);
                
                // Center the model
                const box = new THREE.Box3().setFromObject(dog);
                const center = box.getCenter(new THREE.Vector3());
                dog.position.x += (dog.position.x - center.x);
                dog.position.y += (dog.position.y - center.y) + 0.3;
                dog.position.z += (dog.position.z - center.z);
                
                // Add to container
                dogContainer.add(dog);
                
                // Store the dog model in our fallback dog app
                window.fallbackDogApp.dog = dog;
                
                // Setup animations
                if (gltf.animations && gltf.animations.length) {
                    mixer = new THREE.AnimationMixer(dog);
                    const action = mixer.clipAction(gltf.animations[0]);
                    action.play();
                }
                
                statusEl.textContent = '3D Mode Active - Drag to rotate view';
                logger.info('Dog model loaded in 3D mode');
            },
            (xhr) => {
                const percent = Math.floor(xhr.loaded / xhr.total * 100);
                statusEl.textContent = `Loading dog model: ${percent}%`;
            },
            (error) => {
                console.error('Error loading dog model:', error);
                statusEl.textContent = 'Error loading dog. Using fallback.';
                
                // Create a simple dog placeholder
                createPrimitiveDog(dogContainer);
            }
        );
        
        // Clock for animations
        const clock = new THREE.Clock();
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Update animations
            if (mixer) {
                mixer.update(clock.getDelta());
            }
            
            renderer.render(scene, camera);
        }
        
        // Start animation loop
        animate();
        
        // Connect interaction buttons with behavior interpreter
        document.getElementById('talk').addEventListener('click', () => {
            document.getElementById('speech-input').style.display = 'block';
            document.getElementById('speech-input').focus();
        });
        
        document.getElementById('speech-input').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                const text = document.getElementById('speech-input').value.trim();
                if (text) {
                    statusEl.textContent = `You: ${text}`;
                    document.getElementById('speech-input').value = '';
                    document.getElementById('speech-input').style.display = 'none';
                    
                    // Show dog thinking
                    document.getElementById('thinking').style.display = 'block';
                    
                    // Simulate response after delay
                    setTimeout(() => {
                        document.getElementById('thinking').style.display = 'none';
                        const responses = [
                            "wags tail excitedly",
                            "tilts head curiously",
                            "barks happily",
                            "looks at you with interest"
                        ];
                        const response = responses[Math.floor(Math.random() * responses.length)];
                        statusEl.textContent = `Dog: ${response}`;
                        
                        // Interpret and execute dog behavior based on AI response
                        interpretAndExecute3DModeBehavior(response, dogContainer, mixer);
                    }, 1500);
                }
            }
        });
        
        document.getElementById('pet').addEventListener('click', () => {
            statusEl.textContent = "You pet the dog";
            
            // Show dog thinking
            document.getElementById('thinking').style.display = 'block';
            
            // Simulate response after delay
            setTimeout(() => {
                document.getElementById('thinking').style.display = 'none';
                const response = "wags tail happily and leans into the pets";
                statusEl.textContent = `Dog: ${response}`;
                
                // Interpret and execute dog behavior
                interpretAndExecute3DModeBehavior(response, dogContainer, mixer);
            }, 1000);
        });
        
        document.getElementById('throw-ball').addEventListener('click', () => {
            logger.info('Throw ball button clicked');
            if (window.throwBall) {
                window.throwBall();
            } else if (dogApp) {
                dogApp.throwBall();
            }
        });
        
        document.getElementById('walk').addEventListener('click', () => {
            logger.info('Walk button clicked');
            // Call walkDog directly - this is the safest approach
            walkDog();
        });
        
        // Add a separate behavior interpreter for 3D mode
        function interpretAndExecute3DModeBehavior(response, dogModel, animMixer, ball) {
            logger.info(`3D Mode: Interpreting behavior: "${response}"`);
            
            // For GLTF model with animation mixer
            if (animMixer && animMixer._actions && animMixer._actions.length > 0) {
                // Use the animation mixer
                if (response.includes('wag') || response.includes('excit') || response.includes('happy')) {
                    const action = animMixer.clipAction(animMixer._actions[0].getClip());
                    action.setEffectiveTimeScale(1.5); // Speed up animation for excitement
                    action.play();
                } else if (response.includes('bark') || response.includes('jump')) {
                    const action = animMixer.clipAction(animMixer._actions[0].getClip());
                    action.setEffectiveTimeScale(2.0); // Even faster for barking/jumping
                    action.play();
                } else {
                    const action = animMixer.clipAction(animMixer._actions[0].getClip());
                    action.setEffectiveTimeScale(1.0); // Normal speed for other actions
                    action.play();
                }
            } 
            // For enhanced primitive dog model
            else if (dogModel && dogModel.playAnimation) {
                // Parse the response and play appropriate animations
                if (response.includes('wag') || response.includes('tail')) {
                    dogModel.playAnimation('waggingTail', 3000); // Wag tail for 3 seconds
                    
                    // Chain animations - return to idle after wagging
                    setTimeout(() => {
                        dogModel.playAnimation('idle');
                    }, 3000);
                }
                else if (response.includes('run') || response.includes('chase')) {
                    // If there's a ball to chase
                    if (ball && ball.visible) {
                        dogModel.playAnimation('running', 2000);
                        
                        // Move toward the ball
                        const startPos = dogModel.position.clone();
                        const targetPos = ball.position.clone();
                        
                        // Animate position change
                        const moveStart = Date.now();
                        const moveAnimation = () => {
                            const elapsed = Date.now() - moveStart;
                            if (elapsed < 2000) {
                                const t = elapsed / 2000;
                                
                                // Move dog toward ball
                                dogModel.position.x = startPos.x + (targetPos.x - startPos.x) * t;
                                dogModel.position.z = startPos.z + (targetPos.z - startPos.z) * t;
                                
                                // Look at ball
                                const lookAt = new THREE.Vector3(targetPos.x, dogModel.position.y, targetPos.z);
                                dogModel.lookAt(lookAt);
                                
                                requestAnimationFrame(moveAnimation);
                            } else {
                                // Reached the ball
                                if (ball) ball.visible = false;
                                
                                // Wag tail after getting the ball
                                dogModel.playAnimation('waggingTail', 2000);
                                
                                // Return to idle
                                setTimeout(() => {
                                    dogModel.playAnimation('idle');
                                }, 2000);
                            }
                        };
                        
                        moveAnimation();
                    } else {
                        // Just run in place if no ball
                        dogModel.playAnimation('running', 2500);
                        
                        // Return to idle after running
                        setTimeout(() => {
                            dogModel.playAnimation('idle');
                        }, 2500);
                    }
                }
                else if (response.includes('walk')) {
                    dogModel.playAnimation('walking', 3000);
                    
                    // Return to idle after walking
                    setTimeout(() => {
                        dogModel.playAnimation('idle');
                    }, 3000);
                }
                else if (response.includes('bark')) {
                    dogModel.playAnimation('barking', 1500);
                    
                    // Return to idle after barking
                    setTimeout(() => {
                        dogModel.playAnimation('idle');
                    }, 1500);
                }
                else if (response.includes('tilt') || response.includes('curious')) {
                    dogModel.playAnimation('headTilt', 2000);
                    
                    // Return to idle after head tilt
                    setTimeout(() => {
                        dogModel.playAnimation('idle');
                    }, 2000);
                }
                else {
                    // Default animation
                    dogModel.playAnimation('idle');
                }
            }
            // Basic primitive dog (old version) or simple behavior for any model
            else if (dogModel) {
                if (response.includes('wag') || response.includes('excit') || response.includes('happy')) {
                    // Simple rotation animation for basic model
                    const startTime = Date.now();
                    const rotateAnimation = () => {
                        const elapsed = Date.now() - startTime;
                        if (elapsed < 2000) {
                            dogModel.rotation.y += 0.05;
                            requestAnimationFrame(rotateAnimation);
                        }
                    };
                    rotateAnimation();
                }
            }
        }
    }
    
    // Modify the createPrimitiveDog function for 3D mode to support more behaviors
    function createPrimitiveDog(container) {
        // Body
        const body = new THREE.Mesh(
            new THREE.CapsuleGeometry(0.06, 0.12, 4, 8),
            new THREE.MeshStandardMaterial({ color: 0xA0522D })
        );
        body.rotation.z = Math.PI / 2;
        body.position.y = 0.12;
        container.add(body);
        
        // Head
        const head = new THREE.Mesh(
            new THREE.SphereGeometry(0.045, 16, 16),
            new THREE.MeshStandardMaterial({ color: 0x8B4513 })
        );
        head.position.set(0.09, 0.16, 0);
        container.add(head);
        
        // Eyes
        const eyeGeometry = new THREE.SphereGeometry(0.01, 8, 8);
        const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
        
        const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
        leftEye.position.set(0.12, 0.18, 0.025);
        container.add(leftEye);
        
        const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
        rightEye.position.set(0.12, 0.18, -0.025);
        container.add(rightEye);
        
        // Nose
        const nose = new THREE.Mesh(
            new THREE.SphereGeometry(0.012, 8, 8),
            new THREE.MeshBasicMaterial({ color: 0x000000 })
        );
        nose.position.set(0.14, 0.15, 0);
        container.add(nose);
        
        // Legs
        const legGeometry = new THREE.CylinderGeometry(0.012, 0.012, 0.06, 8);
        const legMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
        
        const legs = [];
        const legPositions = [
            [-0.04, 0.1, 0.04],  // back left
            [-0.04, 0.1, -0.04], // back right
            [0.04, 0.1, 0.04],   // front left
            [0.04, 0.1, -0.04]   // front right
        ];
        
        legPositions.forEach((pos, i) => {
            const leg = new THREE.Mesh(legGeometry, legMaterial);
            leg.position.set(...pos);
            leg.name = `leg${i}`;
            container.add(leg);
            legs.push(leg);
        });
        
        // Tail
        const tail = new THREE.Mesh(
            new THREE.CylinderGeometry(0.01, 0.003, 0.06, 8),
            new THREE.MeshStandardMaterial({ color: 0x8B4513 })
        );
        tail.position.set(-0.1, 0.12, 0);
        tail.rotation.z = Math.PI / 4;
        container.add(tail);
        
        // Move entire container up to clear the ground
        container.position.y = 0.05;
        
        // Animation variables
        let currentAnimation = 'idle';
        let animationStartTime = Date.now();
        let walkDirection = new THREE.Vector3(0, 0, 0);
        
        // Animation states
        const animations = {
            idle: {
                duration: 2000,
                update: (t) => {
                    // Gentle breathing
                    body.position.y = 0.12 + Math.sin(t * Math.PI) * 0.006;
                    head.position.y = 0.16 + Math.sin(t * Math.PI) * 0.006;
                    
                    // Subtle tail movement
                    tail.rotation.z = Math.PI / 4 + Math.sin(t * Math.PI) * 0.05;
                }
            },
            walking: {
                duration: 1000,
                update: (t) => {
                    const cycle = t * Math.PI * 2;
                    
                    // Diagonal leg pairs move together (realistic quadruped walking)
                    // Front left and back right move together, front right and back left move together
                    legs[0].position.y = 0.1 + Math.max(0, Math.sin(cycle)) * 0.02;         // back left
                    legs[3].position.y = 0.1 + Math.max(0, Math.sin(cycle)) * 0.02;         // front right
                    legs[1].position.y = 0.1 + Math.max(0, Math.sin(cycle + Math.PI)) * 0.02; // back right
                    legs[2].position.y = 0.1 + Math.max(0, Math.sin(cycle + Math.PI)) * 0.02; // front left
                    
                    // Add leg forward/backward motion
                    legs[0].position.x = legPositions[0][0] + Math.sin(cycle) * 0.01;
                    legs[1].position.x = legPositions[1][0] + Math.sin(cycle + Math.PI) * 0.01;
                    legs[2].position.x = legPositions[2][0] + Math.sin(cycle + Math.PI) * 0.01;
                    legs[3].position.x = legPositions[3][0] + Math.sin(cycle) * 0.01;
                    
                    // Body moves slightly up and down with the steps
                    body.position.y = 0.12 + Math.sin(cycle * 2) * 0.005;
                    
                    // Head bobs slightly with the walk cycle
                    head.position.y = 0.16 + Math.sin(cycle * 2) * 0.008;
                    
                    // Tail swings with the walk
                    tail.rotation.z = Math.PI / 4 + Math.sin(cycle) * 0.1;
                }
            },
            waggingTail: {
                duration: 400, // Faster for excited tail wagging
                update: (t) => {
                    const cycle = t * Math.PI * 2;
                    
                    // Energetic tail wagging (faster and wider movement)
                    tail.rotation.z = Math.PI / 4 + Math.sin(cycle * 2) * 0.4;
                    tail.rotation.y = Math.sin(cycle * 4) * 0.2;
                    
                    // Dog slightly shifts weight from side to side
                    body.rotation.z = Math.PI / 2 + Math.sin(cycle) * 0.03;
                    
                    // Subtle happy bouncing
                    body.position.y = 0.12 + Math.abs(Math.sin(cycle * 2)) * 0.01;
                    head.position.y = 0.16 + Math.abs(Math.sin(cycle * 2)) * 0.01;
                }
            },
            running: {
                duration: 600, // Faster for running
                update: (t) => {
                    const cycle = t * Math.PI * 3; // Faster cycle for running
                    
                    // Exaggerated leg movements (higher steps)
                    legs[0].position.y = 0.1 + Math.max(0, Math.sin(cycle)) * 0.04;
                    legs[3].position.y = 0.1 + Math.max(0, Math.sin(cycle)) * 0.04;
                    legs[1].position.y = 0.1 + Math.max(0, Math.sin(cycle + Math.PI)) * 0.04;
                    legs[2].position.y = 0.1 + Math.max(0, Math.sin(cycle + Math.PI)) * 0.04;
                    
                    // Forward/backward leg motion
                    legs[0].position.x = legPositions[0][0] + Math.sin(cycle) * 0.02;
                    legs[1].position.x = legPositions[1][0] + Math.sin(cycle + Math.PI) * 0.02;
                    legs[2].position.x = legPositions[2][0] + Math.sin(cycle + Math.PI) * 0.02;
                    legs[3].position.x = legPositions[3][0] + Math.sin(cycle) * 0.02;
                    
                    // More pronounced body movement
                    body.position.y = 0.12 + Math.sin(cycle * 2) * 0.01;
                    
                    // Head bobs more with running
                    head.position.y = 0.16 + Math.sin(cycle * 2) * 0.015;
                    
                    // Tail streams behind when running
                    tail.rotation.z = Math.PI / 5 + Math.sin(cycle) * 0.1;
                }
            },
            barking: {
                duration: 300, // Quick for barking
                update: (t) => {
                    const cycle = t * Math.PI * 2;
                    
                    // Head moves forward slightly when barking
                    head.position.x = 0.09 + Math.abs(Math.sin(cycle * 4)) * 0.01;
                    head.position.y = 0.16 + Math.sin(cycle * 4) * 0.005;
                    
                    // Mouth would open here if we had a separate mouth model
                    
                    // Slight body movement
                    body.position.y = 0.12 + Math.abs(Math.sin(cycle * 4)) * 0.005;
                }
            },
            headTilt: {
                duration: 1500,
                update: (t) => {
                    // Tilt head to one side
                    if (t < 0.3) {
                        // Initial tilt motion
                        head.rotation.z = t/0.3 * 0.3;
                    } else if (t > 0.7) {
                        // Return to normal
                        head.rotation.z = Math.max(0, 0.3 - (t-0.7)/0.3 * 0.3);
                    } else {
                        // Hold the tilt
                        head.rotation.z = 0.3;
                    }
                    
                    // Subtle ear movement would go here if we had ear models
                    
                    // Eyes look up slightly
                    leftEye.position.y = 0.18 + t * 0.005;
                    rightEye.position.y = 0.18 + t * 0.005;
                }
            }
        };
        
        // Function to play a specific animation
        function playAnimation(name, duration = null) {
            if (animations[name]) {
                currentAnimation = name;
                animationStartTime = Date.now();
                
                // Optional custom duration
                if (duration) animations[name].customDuration = duration;
                else delete animations[name].customDuration;
                
                // Reset positions when changing animations
                resetPositions();
            }
        }
        
        // Reset all body parts to default positions
        function resetPositions() {
            // Reset legs
            legs.forEach((leg, i) => {
                leg.position.set(...legPositions[i]);
            });
            
            // Reset head rotation
            head.rotation.set(0, 0, 0);
            
            // Reset eye positions
            leftEye.position.set(0.12, 0.18, 0.025);
            rightEye.position.set(0.12, 0.18, -0.025);
            
            // Reset head position
            head.position.set(0.09, 0.16, 0);
            
            // Reset body
            body.position.y = 0.12;
            body.rotation.z = Math.PI / 2;
            
            // Reset tail
            tail.rotation.z = Math.PI / 4;
            tail.rotation.y = 0;
        }
        
        // Main animation loop
        function animateDog() {
            requestAnimationFrame(animateDog);
            
            const now = Date.now();
            const animation = animations[currentAnimation];
            
            if (animation) {
                const duration = animation.customDuration || animation.duration;
                const elapsed = now - animationStartTime;
                const t = (elapsed % duration) / duration;
                
                animation.update(t);
            }
        }
        
        // Start animation loop
        animateDog();
        
        // Make animations accessible
        container.animations = animations;
        container.playAnimation = playAnimation;
        
        // Default to idle animation
        playAnimation('idle');
        
        logger.info('Enhanced primitive dog created for fallback');
        document.getElementById('status').textContent = '3D Mode Active - Drag to rotate view';
    }
    
    // Walk dog function - simple direct animation without AI
    function walkDog() {
        console.log('Walking the dog (direct animation)');
        
        // Start the walking animation
        const dogApp = window.dogApp || window.fallbackDogApp;
        if (dogApp) {
            dogApp.statusEl.textContent = 'Walking...';
            
            // Debug available animations
            if (dogApp.dogAnimations) {
                console.log('Available animations:', Object.keys(dogApp.dogAnimations));
            } else {
                console.log('No dogAnimations object found');
            }
            
            // Try walking with extra logging
            console.log('Attempting to play walking animation');
            try {
                dogApp.playDogAnimation('walking');
                console.log('Walking animation started');
                
                // Add a manual walking motion as backup
                fakeWalk(dogApp.dog);
            } catch (error) {
                console.error('Error playing walking animation:', error);
                // Still try the fallback
                fakeWalk(dogApp.dog);
            }
            
            // After 5 seconds, return to idle
            setTimeout(() => {
                try {
                    dogApp.playDogAnimation('idle');
                    console.log('Returned to idle animation');
                } catch (error) {
                    console.error('Error returning to idle:', error);
                }
                dogApp.statusEl.textContent = 'Dog placed! Interact with it using the buttons.';
                console.log('Dog walk completed');
            }, 5000);
        } else {
            console.error('Dog app not available');
        }
    }

    // Manual walking animation that moves the dog around in a circle
    function fakeWalk(dogModel) {
        if (!dogModel) {
            console.error('No dog model available for fake walk');
            logger.error('No dog model found for manual walking');
            return;
        }
        
        console.log('Starting manual walk animation');
        logger.info('Starting manual circular walking animation');
        
        // Save the original position
        const originalPosition = {
            x: dogModel.position.x,
            y: dogModel.position.y,
            z: dogModel.position.z
        };
        
        logger.info(`Original position: x=${originalPosition.x}, y=${originalPosition.y}, z=${originalPosition.z}`);
        
        let startTime = Date.now();
        let walkInterval = setInterval(() => {
            const elapsed = Date.now() - startTime;
            if (elapsed > 5000) {
                // Stop walking after 5 seconds
                clearInterval(walkInterval);
                
                // Return to original position
                dogModel.position.set(originalPosition.x, originalPosition.y, originalPosition.z);
                console.log('Manual walk animation completed');
                logger.info('Manual walk animation completed - dog returned to original position');
                return;
            }
            
            try {
                // Walk in a small circle
                const t = elapsed / 5000; // normalized time 0-1
                const radius = 0.3; // 30cm radius circle
                
                // Calculate new position - circular path
                const angle = t * Math.PI * 2;
                const newX = originalPosition.x + radius * Math.cos(angle);
                const newZ = originalPosition.z + radius * Math.sin(angle);
                
                // Update position
                dogModel.position.set(newX, originalPosition.y, newZ);
                
                // Update rotation to face direction of movement
                dogModel.rotation.y = angle + Math.PI/2;
                
                // Log every second to avoid flooding console
                if (Math.floor(elapsed / 1000) !== Math.floor((elapsed - 16) / 1000)) {
                    logger.info(`Dog walking: ${Math.floor(elapsed/50)}% complete`);
                }
            } catch (error) {
                console.error('Error during fake walk animation:', error);
                logger.error('Error during fake walk animation: ' + error.message);
                clearInterval(walkInterval);
            }
        }, 16); // ~60fps
    }

    // Set up event listeners
    document.getElementById('start-ar').addEventListener('click', () => {
        logger.info('Start AR button clicked');
        // Add a user gesture handler for iOS - Safari requires user gesture
        dogApp.startARSession();
    });
    </script>
</body>
</html>